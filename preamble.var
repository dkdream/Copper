/*-*- mode: c;-*-*/
/*-- begin of preamble --*/
#ifndef YY_PREAMBLE
#define YY_PREAMBLE

#define	YYACCEPT yyAccept(yySelf, yystack)

#ifndef YY_CACHE_THUNKS
#define YY_CACHE_THUNKS 100
#endif

static inline void yyStateError() {
    fprintf(stderr, "ERROR IN PARSER STATE\n");
    exit(1);
}

static inline void yyFreeList(YYCacheNode* node) {
    YYCacheNode* next = 0;
    for (; node; node = next) {
        next = node->next;
        free(node);
    }
}

static inline void yyCheckDo(YYClass* yySelf) {
    int end = yySelf->thunkpos;

    if (1 > end) return;

    YYThunk *thunk = yySelf->thunks;
    int      pos   = 0;
    for (;  pos < end;  ++pos) {
        if (thunk[pos].action) continue;
        yySelf->debug_(yySelf, Debug_trace, "    state_check  [%d] error\n", pos);
        fprintf(stderr, "state_check thunk[%d] without an action\n", pos);
        yyStateError();
        break;
    }
}

static inline void yyResizeDo(YYClass* yySelf, int count) {
    int marker = yySelf->thunkpos + count;
    int old    = yySelf->thunkslen;

    if (marker < old) return;

    while (marker >= yySelf->thunkslen) {
        yySelf->thunkslen *= 2;
    }

    yySelf->debug_(yySelf, Debug_trace, "     yyResizeDo %d -> %d\n", old, yySelf->thunkslen);

    if (yySelf->thunks) {
        yySelf->thunks = realloc(yySelf->thunks, sizeof(YYThunk) * yySelf->thunkslen);
    } else {
        yySelf->thunks = malloc(sizeof(YYThunk) * yySelf->thunkslen);
    }

    yyCheckDo(yySelf);
}

static inline void yyDo(YYClass* yySelf, const char* actionname, YYAction action, int arg, YYState state) {

    if (!action) {
        fprintf(stderr, "creating thunk[%d] without an action\n", yySelf->thunkpos);
        yyStateError();
    }

    yyResizeDo(yySelf,1);

    YYThunk *thunk = &(yySelf->thunks[yySelf->thunkpos]);

    yySelf->debug_(yySelf, Debug_action_state, "     yyDo [%d] %p %s\n", yySelf->thunkpos, action, actionname);

    thunk->name     = actionname;
    thunk->begin    = yySelf->begin;
    thunk->end      = yySelf->end;
    thunk->state    = state;
    thunk->action   = action;
    thunk->argument = arg;

    ++yySelf->thunkpos;
}

static inline void yyAddNode(YYClass* yySelf, YYStack *yystack, int result) {
    if (!yySelf->cache) return;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int count = 0;

    if (result) {
        // if no chars are consumed then
        // this may the result of a YYACCEPT not of an optional rule
        // -- skip it
        if (start.current.offset == yySelf->current.offset) return;

        // if no thunks were added then check the length
        if (start.thunkpos != yySelf->thunkpos) {
            count = yySelf->thunkpos - start.thunkpos;

            // wrong direction
            if (0 > count) return;

            // to many
            if (YY_CACHE_THUNKS < count) {
                yySelf->debug_(yySelf, Debug_cache_all, "     not adding cache node (%s,@%d,%d) at %d for %s - to many thunks\n",
                               (result ? "ok" : "fail"), yySelf->current.offset, count,
                               start.current.offset, name);
                return;
            }
        }
    }

    int index = start.current.offset % yySelf->cache->size;

    YYCacheNode* node = malloc(sizeof(YYCacheNode) + (sizeof(YYThunk) * count));

    if (!node) return;

    node->next     = yySelf->cache->slot[index];
    node->begin    = start.current;
    node->function = function;
    node->result   = result;

    if (!result) {
        node->end   = start.current;
        node->count = 0;
    } else {
        node->end   = yySelf->current;
        node->count = count;
        memcpy(node->thunk,
               &(yySelf->thunks[start.thunkpos]),
               sizeof(YYThunk) * node->count);
    }

    yySelf->debug_(yySelf, Debug_cache_all, "     adding cache node (%s,@%d,%d) at %d for %s\n",
                   (node->result ? "ok" : "fail"),
                   node->begin,
                   node->count,
                   node->end,
                   name);

    yySelf->cache->slot[index] = node;
}

static inline int yyCheckNode(YYClass* yySelf, YYStack *yystack, int* result)
{
    if (!yySelf->cache) return 0;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int index = start.current.offset % yySelf->cache->size;

    YYCacheNode* node = yySelf->cache->slot[index];

    for (; node; node = node->next) {
        if (node->begin.offset != start.current.offset) continue;
        if (node->function     != function)             continue;

        *result         = node->result;
        yySelf->current = node->end;

        int count = node->count;

        if (0 < count) {
            yyResizeDo(yySelf, count);

            memcpy(&(yySelf->thunks[yySelf->thunkpos]),
                   node->thunk,
                   sizeof(YYThunk) * count);

            yySelf->thunkpos += count;

            yyCheckDo(yySelf);
        }

        yySelf->debug_(yySelf, Debug_cache_use, "     using cache node (%s,@%d,%d) at %d for %s\n",
                       (node->result ? "ok" : "fail"),
                       node->begin.offset,
                       node->count,
                       node->end.offset,
                       name);

        return 1;
    }

    return 0;
}

static inline void yyDone(YYClass* yySelf) {
    YYThunk *thunk = yySelf->thunks;
    int      pos   = 0;
    for ( ; pos < yySelf->thunkpos;  ++pos) {
        // all action have yyThunkText as there first action so
        yySelf->debug_(yySelf, Debug_action_state, "DO [%d] %p %s : ", pos, thunk[pos].action, thunk[pos].name);

        if (thunk[pos].action) {
            thunk[pos].action(yySelf, thunk[pos]);
        } else {
            yySelf->debug_(yySelf, Debug_action_state, "\n");
        }
    }
    yySelf->thunkpos = 0;
}

static inline void yyResizeVars(YYClass* yySelf, int count) {
    int marker = yySelf->frame + count;

    if (0 > marker) return;

    while (marker >= yySelf->valslen) {
        yySelf->valslen *= 2;
    }

    yySelf->debug_(yySelf, Debug_trace, "do %s %d\n", "stack-resize", yySelf->valslen);

    if (yySelf->vals) {
        yySelf->vals = realloc(yySelf->vals, sizeof(YYSTYPE) * yySelf->valslen);
    } else {
        yySelf->vals = malloc(sizeof(YYSTYPE) * yySelf->valslen);
    }
}

static void yyPush(YYClass* yySelf, YYThunk thunk) {
    // instead of yyThunkText
    yySelf->debug_(yySelf, Debug_action_state, "\n");

    yySelf->debug_(yySelf, Debug_action, "do %s %d\n", "push", thunk.argument);
    /* need to check if yySelf->frame + thunk.argument >= yySelf->valslen */
    yyResizeVars(yySelf, thunk.argument);
    yySelf->frame += thunk.argument;
}

static void yyPop(YYClass* yySelf, YYThunk thunk) {
    // instead of yyThunkText
    yySelf->debug_(yySelf, Debug_action_state, "\n");

    yySelf->debug_(yySelf, Debug_action, "do %s %d\n", "pop", thunk.argument);
    yySelf->frame -= thunk.argument;
    /* need to check if yySelf->frame < 0 */
}

static void yySet(YYClass* yySelf, YYThunk thunk) {
    // instead of yyThunkText
    yySelf->debug_(yySelf, Debug_action_state, "\n");

    yySelf->debug_(yySelf, Debug_action, "do %s v[%d] = %d\n", "set", thunk.argument,  yySelf->result);

    /* need to check if yySelf->frame + thunk.argument >= yySelf->valslen */
    yySelf->vals[yySelf->frame + thunk.argument] = yySelf->result;
}

static inline int yyThunkText(YYClass* yySelf, YYThunk thunk) {
    int begin  = thunk.begin.offset;
    int end    = thunk.end.offset;
    int length = end - begin;

    if (length <= 0)
        length = 0;
    else {
        char* target = yySelf->text;
        char* source = yySelf->buf + begin;
        int   limit  = yySelf->textlen;

        if (limit < (length - 1)) {
            while (limit < (length - 1)) {
                limit *= 2;
                target= realloc(target, limit);
            }

            yySelf->textlen = limit;
            yySelf->text    = target;
        }

        memcpy(target, source, length);
    }

    yySelf->text[length]= '\0';

    yySelf->debug_(yySelf, Debug_action_state, "GET thunk text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

    return length;
}

static inline int yyrefill(YYClass* yySelf) {
    yySelf->debug_(yySelf, Debug_trace, "     yyrefill\n");

    int yyn = 0;

    const int point  = yySelf->current.offset;
    const int length = yySelf->buflen;

    if (length - point > 512) {
        yyn = yySelf->input_(yySelf, yySelf->buf + point, length - point);
    } else {
        int newsize = length;

        while (newsize - point < 512) {
            newsize *= 2;
        }

        yySelf->buf    = realloc(yySelf->buf, newsize+2);
        yySelf->buflen = newsize;

        yyn = yySelf->input_(yySelf, yySelf->buf + point, newsize - point);
    }

    yySelf->buf[yySelf->limit + yyn] = 0;

    if (0 == yyn) return 0;

    yySelf->limit += yyn;

    return 1;
}

static inline int yyCheckBuffer(YYClass* yySelf) {
    int point = yySelf->current.offset;
    return (point >= yySelf->limit && !yyrefill(yySelf));
}

static inline void yyCheckReached(YYClass* yySelf, YYPoint here) {
    if (yySelf->reached.offset < here.offset) {
        yySelf->reached = here;
    }
}

static inline void yyCheckNewline(YYClass* yySelf) {
    int point = yySelf->current.offset;
    int chr   = yySelf->buf[point];

    if ('\n' == chr) {
        yySelf->current.lineno  += 1;
        yySelf->current.position = 0;
        return;
    }

    if ('\r' == chr) {
        yySelf->current.lineno  += 1;
        yySelf->current.position = 0;
        return;
    }

    yySelf->current.position += 1;
}

static inline char yyCurrentChar(YYClass* yySelf) {
    int point = yySelf->current.offset;
    return yySelf->buf[point];
}

static inline void yyNextChar(YYClass* yySelf) {
    yySelf->current.offset += 1;
    yyCheckNewline(yySelf);
}

static inline int yymatchDot(YYClass* yySelf) {
    if (yyCheckBuffer(yySelf)) return 0;
    yyNextChar(yySelf);
    return 1;
}

static inline int yymatchChar(YYClass* yySelf, int c) {
    if (yyCheckBuffer(yySelf)) return 0;

    if (yyCurrentChar(yySelf) == c) {
        yyNextChar(yySelf);
        return 1;
    }

    return 0;
}

static inline int yymatchString(YYClass* yySelf, const char *s) {
    YYPoint yysav = yySelf->current;

    while (*s) {
        if (yyCheckBuffer(yySelf)) {
            yySelf->current = yysav;
            return 0;
        }
        if (yyCurrentChar(yySelf) != *s) {
            yySelf->current = yysav;
            return 0;
        }
        ++s;
        yyNextChar(yySelf);
    }
    return 1;
}

static inline int yymatchClass(YYClass* yySelf, const char* cls, unsigned char *bits) {
    if (yyCheckBuffer(yySelf)) return 0;

    int chr = yyCurrentChar(yySelf);

    if (bits[chr >> 3] & (1 << (chr & 7))) {
        yyNextChar(yySelf);
        return 1;
    }

    return 0;
}

static inline void yy_no_warings() {
    /* this is here to stop 'defined but not used' warnings */

    // for references ONLY
    (void)yyPush;
    (void)yyPop;
    (void)yySet;
    (void)yymatchDot;
    (void)yymatchChar;
    (void)yymatchString;
    (void)yymatchClass;
    (void)yyDo;
    (void)yyAccept;
}

#endif
/*-- end of preamble --*/

