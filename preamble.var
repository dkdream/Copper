/*-*- mode: c;-*-*/
/*-- begin of preamble --*/
#ifndef YY_PREAMBLE
#define YY_PREAMBLE

#ifndef YY_SEND
#define YY_SEND(method, args...) yySelf->method(yySelf, ## args)
#endif

#define	YYACCEPT yyAccept(yySelf, yystack)

#ifndef YY_CACHE_THUNKS
#define YY_CACHE_THUNKS 100
#endif

static inline void yyStateError() {
  fprintf(stderr, "ERROR IN PARSER STATE\n");
  exit(1);
}

static inline void yyFreeList(YYCacheNode* node) {
  YYCacheNode* next = 0;
  for (; node; node = next) {
    next = node->next;
    free(node);
  }
}

static inline void yyCheckDo(YYClass* yySelf) {
  int end = yySelf->thunkpos;

  if (1 > end) return;

  YYThunk *thunk = yySelf->thunks;
  int      pos   = 0;
  for (;  pos < end;  ++pos) {
    if (thunk[pos].action) continue;
    YY_SEND(debug_, Debug_trace, "    state_check  [%d] error\n", pos);
    fprintf(stderr, "state_check thunk[%d] without an action\n", pos);
    yyStateError();
    break;
  }
}

static inline void yyResizeDo(YYClass* yySelf, int count) {
  int marker = yySelf->thunkpos + count;
  int old    = yySelf->thunkslen;

  if (marker < old) return;

  while (marker >= yySelf->thunkslen) {
    yySelf->thunkslen *= 2;
  }

  YY_SEND(debug_, Debug_trace, "     yyResizeDo %d -> %d\n", old, yySelf->thunkslen);

  if (yySelf->thunks) {
    yySelf->thunks = realloc(yySelf->thunks, sizeof(YYThunk) * yySelf->thunkslen);
  } else {
    yySelf->thunks = malloc(sizeof(YYThunk) * yySelf->thunkslen);
  }

  yyCheckDo(yySelf);
}

static inline void yyDo(YYClass* yySelf, const char* actionname, YYAction action, int arg, YYState state) {

  if (!action) {
    fprintf(stderr, "creating thunk[%d] without an action\n", yySelf->thunkpos);
    yyStateError();
  }

  yyResizeDo(yySelf,1);

  YYThunk *thunk = &(yySelf->thunks[yySelf->thunkpos]);

  YY_SEND(debug_, Debug_action_state, "     yyDo [%d] %p %s\n", yySelf->thunkpos, action, actionname);

  thunk->name     = actionname;
  thunk->begin    = yySelf->begin;
  thunk->end      = yySelf->end;
  thunk->state    = state;
  thunk->action   = action;
  thunk->argument = arg;

  ++yySelf->thunkpos;
}

static inline void yyAddNode(YYClass* yySelf, YYStack *yystack, int result) {
  if (!yySelf->cache) return;

  const char* name = yystack->name;
  YYRule  function = yystack->current;
  YYState    start = yystack->begin;

  int count = 0;

  if (result) {
    // if no chars are consumed then
    // this may the result of a YYACCEPT not of an optional rule
    // -- skip it
    if (start.pos == yySelf->pos) return;

    // if no thunks were added then check the length
    if (start.thunkpos != yySelf->thunkpos) {
      count = yySelf->thunkpos - start.thunkpos;

      // wrong direction
      if (0 > count) return;

      // to many
      if (YY_CACHE_THUNKS < count) {
        YY_SEND(debug_, Debug_cache_all, "     not adding cache node (%s,@%d,%d) at %d for %s - to many thunks\n",
                (result ? "ok" : "fail"), yySelf->pos, count,
                start.pos, name);
        return;
      }
    }
  }

  int index = start.pos % yySelf->cache->size;

  YYCacheNode* node = malloc(sizeof(YYCacheNode) + (sizeof(YYThunk) * count));

  if (!node) return;

  node->next     = yySelf->cache->slot[index];
  node->location = start.pos;
  node->function = function;
  node->result   = result;

  if (!result) {
    node->pos = start.pos;
    node->count = 0;
  } else {
    node->pos   = yySelf->pos;
    node->count = count;
    memcpy(node->thunk,
           &(yySelf->thunks[start.thunkpos]),
           sizeof(YYThunk) * node->count);
  }

  YY_SEND(debug_, Debug_cache_all, "     adding cache node (%s,@%d,%d) at %d for %s\n",
          (node->result ? "ok" : "fail"), node->pos, node->count,
          node->location, name);

  yySelf->cache->slot[index] = node;
}

static inline int yyCheckNode(YYClass* yySelf, YYStack *yystack, int* result)
{
  if (!yySelf->cache) return 0;

  const char* name = yystack->name;
  YYRule  function = yystack->current;
  YYState    start = yystack->begin;

  int index = start.pos % yySelf->cache->size;

  YYCacheNode* node = yySelf->cache->slot[index];

  for (; node; node = node->next) {
    if (node->location != start.pos) continue;
    if (node->function != function) continue;

    *result     = node->result;
    yySelf->pos = node->pos;

    int count = node->count;

    if (0 < count) {
      yyResizeDo(yySelf, count);

      memcpy(&(yySelf->thunks[yySelf->thunkpos]),
             node->thunk,
             sizeof(YYThunk) * count);

      yySelf->thunkpos += count;

      yyCheckDo(yySelf);
    }

    YY_SEND(debug_, Debug_cache_use, "     using cache node (%s,@%d,%d) at %d for %s\n",
            (node->result ? "ok" : "fail"), node->pos, node->count,
            node->location, name);

    return 1;
  }

  return 0;
}

static inline void yyDone(YYClass* yySelf) {
  YYThunk *thunk = yySelf->thunks;
  int      pos   = 0;
  for ( ; pos < yySelf->thunkpos;  ++pos) {
    // all action have yyThunkText as there first action so
    YY_SEND(debug_, Debug_action_state, "DO [%d] %p %s : ", pos, thunk[pos].action, thunk[pos].name);

    if (thunk[pos].action) {
      thunk[pos].action(yySelf, thunk[pos]);
    } else {
      YY_SEND(debug_, Debug_action_state, "\n");
    }
  }
  yySelf->thunkpos = 0;
}

static inline void yyResizeVars(YYClass* yySelf, int count) {
  int marker = yySelf->frame + count;

  if (0 > marker) return;

  while (marker >= yySelf->valslen) {
    yySelf->valslen *= 2;
  }

  YY_SEND(debug_, Debug_trace, "do %s %d\n", "stack-resize", yySelf->valslen);

  if (yySelf->vals) {
    yySelf->vals = realloc(yySelf->vals, sizeof(YYSTYPE) * yySelf->valslen);
  } else {
    yySelf->vals = malloc(sizeof(YYSTYPE) * yySelf->valslen);
  }
}

static void yyPush(YYClass* yySelf, YYThunk thunk) {
  // instead of yyThunkText
  YY_SEND(debug_, Debug_action_state, "\n");

  YY_SEND(debug_, Debug_action, "do %s %d\n", "push", thunk.argument);
  /* need to check if yySelf->frame + thunk.argument >= yySelf->valslen */
  yyResizeVars(yySelf, thunk.argument);
  yySelf->frame += thunk.argument;
}

static void yyPop(YYClass* yySelf, YYThunk thunk) {
  // instead of yyThunkText
  YY_SEND(debug_, Debug_action_state, "\n");

  YY_SEND(debug_, Debug_action, "do %s %d\n", "pop", thunk.argument);
  yySelf->frame -= thunk.argument;
  /* need to check if yySelf->frame < 0 */
}

static void yySet(YYClass* yySelf, YYThunk thunk) {
  // instead of yyThunkText
  YY_SEND(debug_, Debug_action_state, "\n");

  YY_SEND(debug_, Debug_action, "do %s v[%d] = %d\n", "set", thunk.argument,  yySelf->result);

  /* need to check if yySelf->frame + thunk.argument >= yySelf->valslen */
  yySelf->vals[yySelf->frame + thunk.argument] = yySelf->result;
}

static inline int yyThunkText(YYClass* yySelf, YYThunk thunk) {
  int begin  = thunk.begin;
  int end    = thunk.end;
  int length = end - begin;

  if (length <= 0)
    length = 0;
  else {
    char* target = yySelf->text;
    char* source = yySelf->buf + begin;
    int   limit  = yySelf->textlen;

    if (limit < (length - 1)) {
      while (limit < (length - 1)) {
        limit *= 2;
        target= realloc(target, limit);
      }

      yySelf->textlen = limit;
      yySelf->text    = target;
    }

    memcpy(target, source, length);
  }

  yySelf->text[length]= '\0';

  YY_SEND(debug_, Debug_action_state, "GET thunk text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

  return length;
}

static inline int yyrefill(YYClass* yySelf) {
  YY_SEND(debug_, Debug_trace, "     yyrefill\n");

  if (yySelf->buflen - yySelf->pos < 512) {
    while (yySelf->buflen - yySelf->pos < 512) {
      yySelf->buflen *= 2;
    }

    yySelf->buf = realloc(yySelf->buf, yySelf->buflen+2);
    yySelf->buf[yySelf->limit] = 0;
  }

  //  int yyn = YY_INPUT(yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);
  //  int yyn = yySelf->input_(yySelf, yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);
  int yyn = YY_SEND(input_, yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);

  if (0 == yyn) return 0;

  yySelf->limit += yyn;
  yySelf->buf[yySelf->limit] = 0;

  return 1;
}

static inline int yymatchDot(YYClass* yySelf) {
  if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;
  yySelf->pos += 1;
  return 1;
}

static inline int yymatchChar(YYClass* yySelf, int c) {
  if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

  if (yySelf->buf[yySelf->pos] == c) {
    yySelf->pos += 1;
    return 1;
  }

  return 0;
}

static inline int yymatchString(YYClass* yySelf, char *s) {
  int yysav= yySelf->pos;
  while (*s) {
    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) {
      yySelf->pos= yysav;
      return 0;
    }
    if (yySelf->buf[yySelf->pos] != *s) {
      yySelf->pos= yysav;
      return 0;
    }
    ++s;
    yySelf->pos += 1;
  }
  return 1;
}

static inline int yymatchClass(YYClass* yySelf, const char* cls, unsigned char *bits) {
  int chr;

  if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

  chr = yySelf->buf[yySelf->pos];

  if (bits[chr >> 3] & (1 << (chr & 7))) {
    ++yySelf->pos;
    return 1;
  }

  return 0;
}

static inline void yy_no_warings() {
  /* this is here to stop 'defined but not used' warnings */

  // for references ONLY
  (void)yyPush;
  (void)yyPop;
  (void)yySet;
  (void)yymatchDot;
  (void)yymatchChar;
  (void)yymatchString;
  (void)yymatchClass;
  (void)yyDo;
  (void)yyAccept;
}

#endif
/*-- end of preamble --*/

