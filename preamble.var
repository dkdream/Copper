/*-*- mode: c;-*-*/

#define YY_SAVE(state)    { state.pos = yySelf->pos; state.thunkpos = yySelf->thunkpos; }
#define YY_RESTORE(state) { yySelf->pos = state.pos; yySelf->thunkpos = state.thunkpos; }

/* begin of yytext */
#define YY_BEGIN ( yySelf->begin = yySelf->pos, yySelf->end = yySelf->pos, 1)

/* end of yytext */
#define YY_END (yySelf->end = yySelf->pos, 1)

#define YY_SEND(method, args...) yySelf->method(yySelf, ## args)
#define YY_CALL(method)          yySelf->method(yySelf)

#ifndef YY_DEBUG
#ifndef DEBUGGING
#define YY_DEBUG(format, args...)
#else
#define YY_DEBUG(format, args...) fprintf(stderr, format, ## args)
#endif
#endif

/* user defined mark (useful in marking parse stack) */
#ifndef YY_MARK
#define YY_MARK
#endif

/* user defined collect (useful in collecting from a parse stack) */
#ifndef YY_COLLECT
#define YY_COLLECT
#endif

#ifndef YY_CACHE_SLOTS
#define YY_CACHE_SLOTS 1023
#endif

#ifndef YY_CACHE_THUNKS
#define YY_CACHE_THUNKS 10
#endif

#ifndef YY_PART

typedef struct _yycache_node YYCacheNode;

struct _yystate {
    int pos;
    int thunkpos;
};

struct _yystack {
    YYStack*    next;
    const char* name;
    YYRule      current;
    YYState     begin;
};

struct _yythunk {
    int        begin;
    int        end;
    YYState    state;
    YYAction   action;
    YYArgument argument;
};

struct _yycache_node {
    YYCacheNode* next;
    int     location;
    void*   function;
    int     result;
    int     pos;
    int     begin;
    int     end;
    int     count;
    YYThunk thunk[0];
};

struct _yycache {
    int size;
    YYCacheNode* slot[0];
};

static void save_method(YYClass* yySelf, YYState* state) {
    state->pos = yySelf->pos;
    state->thunkpos = yySelf->thunkpos;
}

static void restore_method(YYClass* yySelf, YYState* state) {
    yySelf->pos = state->pos;
    yySelf->thunkpos = state->thunkpos;
}

static void begin_method(YYClass* yySelf) {
    yySelf->begin = yySelf->pos;
    yySelf->end   = yySelf->pos;
}

static void end_method(YYClass* yySelf) {
    yySelf->end = yySelf->pos;
}

static int input_method(YYClass* yySelf, char* buffer, int max_size) {
#ifdef YY_INPUT
    return YY_INPUT(buffer, max_size);
#else
    int yyc = getchar();
    if (EOF == yyc) return 0;
    buffer[0] = yyc;
    return 1;
#endif
}

static void debug_method(YYClass* yySelf, const char* format, ...) {
}

static void mark_method(YYClass* yySelf) {
    YY_MARK;
}

static void collect_method(YYClass* yySelf) {
    YY_COLLECT;
}

static inline void yyInit(YYClass* yySelf) {
    yySelf->buf       = 0;
    yySelf->buflen    = 0;
    yySelf->pos       = 0;
    yySelf->limit     = 0;
    yySelf->text      = 0;
    yySelf->textlen   = 0;
    yySelf->begin     = 0;
    yySelf->end       = 0;
    yySelf->textmax   = 0;
    yySelf->thunks    = 0;
    yySelf->thunkslen = 0;
    yySelf->thunkpos  = 0;
    yySelf->frame     = 0;
    yySelf->vals      = 0;
    yySelf->valslen   = 0;
    yySelf->cache     = 0;

    yySelf->input_   = input_method;
    yySelf->save_    = save_method;
    yySelf->restore_ = restore_method;
    yySelf->begin_   = begin_method;
    yySelf->end_     = end_method;
    yySelf->debug_   = debug_method;
    yySelf->mark_    = mark_method;
    yySelf->collect_ = collect_method;
}

static inline void yyStart(YYClass* yySelf) {
    if (yySelf->buflen) return;

    yySelf->buflen    = 1024;
    yySelf->buf       = malloc(yySelf->buflen);
    yySelf->textlen   = 1024;
    yySelf->text      = malloc(yySelf->textlen);
    yySelf->thunkslen = 32;
    yySelf->thunks    = malloc(sizeof(YYThunk) * yySelf->thunkslen);
    yySelf->valslen   = 32;
    yySelf->vals      = malloc(sizeof(YYSTYPE) * yySelf->valslen);
    yySelf->begin     = yySelf->end = yySelf->pos = yySelf->limit = yySelf->thunkpos = 0;
    yySelf->text[0]   = '\0';
    yySelf->frame     = 0;
}

static inline void yyFreeList(YYCacheNode* node) {
    YYCacheNode* next = 0;
    for (; node; node = next) {
        next = node->next;
        free(node);
    }
}

static inline void yyClearCache(YYClass* yySelf) {
    YY_DEBUG("     yyClearCache\n");
    if (!yySelf->cache) {
        yySelf->cache = malloc(sizeof(struct _yycache) + (sizeof(YYCacheNode*) * YY_CACHE_SLOTS));
        yySelf->cache->size = YY_CACHE_SLOTS;
        int size = yySelf->cache->size;
        for (; size--;) {
            yySelf->cache->slot[size] = 0;
        }
    } else {
        int size = yySelf->cache->size;
        for (; size--;) {
            YYCacheNode* node = yySelf->cache->slot[size];
            yyFreeList(node);
            yySelf->cache->slot[size] = 0;
        }
    }
}

static inline void yyResizeDo(YYClass* yySelf, int count) {
    while ((yySelf->thunkpos + count) >= yySelf->thunkslen) {
        yySelf->thunkslen *= 2;
        yySelf->thunks     = realloc(yySelf->thunks, sizeof(YYThunk) * yySelf->thunkslen);
    }
}

static inline void yyAddNode(YYClass* yySelf, YYStack *yystack, int result) {
    if (!yySelf->cache) return;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int count = 0;

    if (result) {
        // if no chars are consumed then
        // this may the result of a YYACCEPT not of an optional rule
        // -- skip it
        if (start.pos == yySelf->pos) return;

        // if no thunks were added then check check the length
        if (start.thunkpos != yySelf->thunkpos) {
            count = yySelf->thunkpos - start.thunkpos;
            // wrong direction
            if (0 > count) return;
            // to many
            if (YY_CACHE_THUNKS < count) {
                YY_DEBUG("     not adding cache node (%s,@%d,%d) at %d for %s - to many thunks\n",
                         (result ? "ok" : "fail"), yySelf->pos, count,
                         start.pos, name);
                return;
            }
            // return;
        }
    }

    int index = start.pos % yySelf->cache->size;

    YYCacheNode* node =  malloc(sizeof(YYCacheNode) + (sizeof(YYCacheNode) * count));

    if (!node) return;

    node->next     = yySelf->cache->slot[index];
    node->location = start.pos;
    node->function = function;
    node->result   = result;
    node->begin    = yySelf->begin;
    node->end      = yySelf->end;

    if (result) {
        node->pos = yySelf->pos;
        node->count = count;
        YYThunk* to   = &(node->thunk[0]);
        YYThunk* from = &(yySelf->thunks[start.thunkpos]);
        for (; count--; ++to, ++from) {
            *to = *from;
        }
    } else {
        node->pos = start.pos;
        node->count = 0;
    }

    YY_DEBUG("     adding cache node (%s,@%d,%d) at %d for %s\n",
             (node->result ? "ok" : "fail"), node->pos, node->count,
             node->location, name);

    yySelf->cache->slot[index] = node;
}

static inline int yyCheckNode(YYClass* yySelf, YYStack *yystack, int* result)
{
    if (!yySelf->cache) return 0;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int index = start.pos % yySelf->cache->size;

    YYCacheNode* node = yySelf->cache->slot[index];

    for (; node; node = node->next) {
        if (node->location != start.pos) continue;
        if (node->function != function) continue;
        *result = node->result;
        yySelf->pos   = node->pos;
        yySelf->begin = node->begin;
        yySelf->end   = node->end;

        int count = node->count;

        YYThunk* from = &(node->thunk[0]);
        YYThunk* to   = &(yySelf->thunks[yySelf->thunkpos]);

        if (0 < count) {
            yyResizeDo(yySelf, count);
            yySelf->thunkpos += count;
            for (; count--; ++to, ++from) {
                *to = *from;
            }
        }

        YY_DEBUG("     using cache node (%s,@%d,%d) at %d for %s\n",
                 (node->result ? "ok" : "fail"), node->pos, node->count,
                 node->location, name);

        return 1;
    }

    return 0;
}

static inline int yyrefill(YYClass* yySelf) {
    YY_DEBUG("     yyrefill\n");

    if (yySelf->buflen - yySelf->pos < 512) {
        while (yySelf->buflen - yySelf->pos < 512) {
            yySelf->buflen *= 2;
            yySelf->buf     = realloc(yySelf->buf, yySelf->buflen+2);
        }
        yySelf->buf[yySelf->limit] = 0;
    }

    //    int yyn = YY_INPUT(yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);
    int yyn = yySelf->input_(yySelf, yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);

    if (0 == yyn) return 0;

    yySelf->limit += yyn;
    yySelf->buf[yySelf->limit] = 0;

    return 1;
}

static inline int yymatchDot(YYClass* yySelf) {
    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;
    yySelf->pos += 1;
    return 1;
}

static inline int yymatchChar(YYClass* yySelf, int c) {
    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

    if (yySelf->buf[yySelf->pos] == c) {
        yySelf->pos += 1;
        return 1;
    }

    return 0;
}

static inline int yymatchString(YYClass* yySelf, char *s) {
    int yysav= yySelf->pos;
    while (*s) {
        if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) {
            yySelf->pos= yysav;
            return 0;
        }
        if (yySelf->buf[yySelf->pos] != *s) {
            yySelf->pos= yysav;
            return 0;
        }
        ++s;
        yySelf->pos += 1;
    }
    return 1;
}

static inline int yymatchClass(YYClass* yySelf, const char* cls, unsigned char *bits) {
    int chr;

    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

    chr = yySelf->buf[yySelf->pos];

    if (bits[chr >> 3] & (1 << (chr & 7))) {
        ++yySelf->pos;
        return 1;
    }

    return 0;
}

static inline void yyDo(YYClass* yySelf, YYAction action, YYArgument arg, YYState state) {

    yyResizeDo(yySelf,1);

    YYThunk *thunk = &(yySelf->thunks[yySelf->thunkpos]);

    thunk->begin    = yySelf->begin;
    thunk->end      = yySelf->end;
    thunk->state    = state;
    thunk->action   = action;
    thunk->argument = arg;

    ++yySelf->thunkpos;
}

static int yyBegin(YYClass* yySelf) {
    yySelf->begin = yySelf->pos;
    yySelf->end   = yySelf->pos;

    YY_DEBUG("BEGIN %d\n", yySelf->begin);

    return 1;
}

static inline int yyText(YYClass* yySelf) {
    int begin  = yySelf->begin;
    int end    = yySelf->end;
    int length = end - begin;

    if (length <= 0)
        length = 0;
    else {
        int   textlen = yySelf->textlen;
        char* text    = yySelf->text;

        if (textlen < (length - 1)) {
            while (textlen < (length - 1)) {
                textlen *= 2;
                text= realloc(text, textlen);
            }

            yySelf->textlen = textlen;
            yySelf->text    = text;
        }

        memcpy(text, yySelf->buf + begin, length);
    }

    yySelf->text[length]= '\0';

    //    YY_DEBUG("GET text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

    return length;
}

static int yyEnd(YYClass* yySelf) {
    yySelf->end = yySelf->pos;

    int length = yyText(yySelf);

    if (0 < length) {
        YY_DEBUG("END %d \'%s\'\n", yySelf->end, yySelf->text);
    } else {
        YY_DEBUG("END %d\n", yySelf->end);
    }

    return 1;
}

static inline int yyThunkText(YYClass* yySelf, YYThunk thunk) {
    int begin  = thunk.begin;
    int end    = thunk.end;
    int length = end - begin;

    if (length <= 0)
        length = 0;
    else {
        char* target = yySelf->text;
        char* source = yySelf->buf + begin;
        int   limit  = yySelf->textlen;

        if (limit < (length - 1)) {
            while (limit < (length - 1)) {
                limit *= 2;
                target= realloc(target, limit);
            }

            yySelf->textlen = limit;
            yySelf->text    = target;
        }

        memcpy(target, source, length);
    }

    yySelf->text[length]= '\0';

    //    YY_DEBUG("GET thunk text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

    return length;
}

static inline void yyDone(YYClass* yySelf) {
    int pos;
    for (pos = 0;  pos < yySelf->thunkpos;  ++pos) {
        YYThunk *thunk = &yySelf->thunks[pos];

        YY_DEBUG("DO [%d] %p : ", pos, thunk->action);

        thunk->action(yySelf, yySelf->thunks[pos]);
    }
    yySelf->thunkpos = 0;
}

static inline void yyCommit(YYClass* yySelf) {

    if ((yySelf->limit -= yySelf->pos)) {
        memmove(yySelf->buf, yySelf->buf + yySelf->pos, yySelf->limit);
    }

    yySelf->buf[yySelf->limit] = 0;

    yySelf->begin -= yySelf->pos;
    yySelf->end   -= yySelf->pos;

    if (0 > yySelf->begin) yySelf->begin = 0;
    if (0 > yySelf->end)   yySelf->end = 0;

    yySelf->pos = yySelf->thunkpos = 0;

    yyClearCache(yySelf);
}

static inline int yyAccept(YYClass* yySelf, YYStack* yystack) {
    int tp0 = yystack->begin.thunkpos;

    if (tp0) {
        fprintf(stderr, "accept denied at %d", tp0);
        return 0;
    } else {
        YY_DEBUG("    yyAccept begin\n");
        yyDone(yySelf);
        yyCommit(yySelf);
        YY_DEBUG("    yyAccept end\n");
    }
    return 1;
}

static void yyPush(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s %d\n", "push", thunk.argument);
    /* need to check if yySelf->frame > yySelf->valslen */
    yySelf->frame += thunk.argument;
}

static void yyPop(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s %d\n", "pop", thunk.argument);
    yySelf->frame -= thunk.argument;
    /* need to check if yySelf->frame < 0 */
}

static void yySet(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s v[%d] = %d\n", "set", thunk.argument,  yySelf->result);
    yySelf->vals[yySelf->frame + thunk.argument] = yySelf->result;
}

static int yyCall(YYClass* yySelf, YYStack* yystack, YYRule function, const char* name) {
    YYStack yytop;
    YYState yystate;

    yytop.next    = yystack;
    yytop.current = function;
    yytop.name    = name;

    YY_SAVE(yytop.begin);

    YY_DEBUG("start(%i) %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);

    int result;

    if (yyCheckNode(yySelf, &yytop, &result)) {
        return result;
    } else {
        result = function(yySelf, &yytop);
    }

    yyAddNode(yySelf, &yytop, result);

    if (result) {
        YY_DEBUG("  ok(%i)   %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);
    } else {
        YY_DEBUG("  fail(%i) %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);
        YY_RESTORE(yytop.begin);
    }

    return result;
}

#endif /* YY_PART */

#define	YYACCEPT yyAccept(yySelf, yystack)

/*-- end of preamble --*/

