%{
#include <stdio.h>
#include <unistd.h>

FILE *input  = 0;
FILE *output = 0;

static int   lineNumber = 0;
static char *fileName   = 0;
static int   do_debug   = 0;

void yyerror(char *message);
int  doMatch(char *message, char chr);
void doDone();

static void zero(char* buf, int size) {
  while (size--) {
     *buf++ = 0;
  }
}

static int next_Char(char* buffer, int max) {
   zero(buffer,max);
   int c = getc(input); 
   if ('\n' == c || '\r' == c) ++lineNumber;
   if (EOF == c) {
     return 0;
   } else {
     *(buffer)= c;
     return 1;
   }
}

static inline void add_keyword(const char *text) {
}

#define YY_INPUT(buf, result, max) { result = next_Char(buf, max); }

#define YY_DONE doDone()
#define YY_LOCAL(T)     static T
#define YY_RULE(T)      static T
%}

Program = Spacing ( NamedFunction | Statement )*

NamedFunction  = Function_kw LABEL  Open_kw Parameters? Close_kw Begin_kw Statement* End_kw
LambdaFunction = Function_kw Open_kw Parameters? Close_kw Begin_kw Statement* End_kw
Parameters     = Parameter ( Comma_kw Parameter )*
Parameter      = LABEL

TryStatement  = Try_kw BlockStatement CatchClause* FinallyClause?
CatchClause   = Catch_kw Open_kw LABEL Close_kw BlockStatement
FinallyClause = Finally_kw BlockStatement

ReturnStatement   = Return_kw Expression?
ThrowStatement    = Throw_kw  Expression
ContinueStatement = Continue_kw LABEL?
BreakStatement    = Break_kw LABEL?
WithStatement     = With_kw Open_kw Expression Close_kw Statement

ForStatement = For_kw Open_kw Close_kw Statement
ForCondition = ForInit Semi_kw Expression? Semi_kw Expression?
             | ForIn   In_kw Expression 
ForInit = ( DeclareStatement  | Expression )?
ForIn   = ( ( Var_kw | Let_kw ) LABEL | Expression )

WhileStatement  = While_kw Open_kw Expression Close_kw Statement
DoStatement     = Do_kw Statement While_kw Open_kw Expression Close_kw

SwitchStatement = Switch_kw Open_kw Expression Close_kw Begin_kw CaseClause* LastClause End_kw
CaseClause      = CaseGuard+ Statement+
LastClause      = CaseGuard+ Statement*
CaseGuard       = ( Case_kw Expression | Default_kw ) Alternitive_kw

IfStatement      = If_kw Open_kw Expression Close_kw Statement ( Else_kw Statement )?
LabeledStatement = LABEL Alternitive_kw Statement
BlockStatement   = Begin_kw Statement* End_kw

DeclareStatement = ( Var_kw | Let_kw ) Assignment ( Sequence_kw Assignment )*
Assignment       = LABEL Assign_kw Expression

ExpressionStatement = Expression
EmptyStatement      = Semi_kw

Statement = TryStatement
          | ReturnStatement    Semi_kw?
          | ThrowStatement     Semi_kw?
          | ContinueStatement  Semi_kw?
          | BreakStatement     Semi_kw?
          | WithStatement
          | ForStatement
          | WhileStatement
          | DoStatement         Semi_kw?
          | SwitchStatement
          | IfStatement
          | LabeledStatement
          | BlockStatement
          | DeclareStatement    Semi_kw?
          | ExpressionStatement Semi_kw?
          | EmptyStatement

Expression = AssignmentExpression  ( Sequence_kw AssignmentExpression )*

AssignmentExpression = ConditionalExpression
                     | Reference AssignmentOperator AssignmentExpression

Reference = ReferencePrefix ReferenceSuffix
          | LABEL

ReferencePrefix = MemberExpression | Constructor 
ReferenceSuffix = Dot_kw LABEL
                | SOpen_kw AssignmentExpression (Comma_kw AssignmentExpression)* SClose_kw

ConditionalExpression    = OrExpression             ( Condition_kw AssignmentExpression Alternitive_kw AssignmentExpression )?
OrExpression             = AndExpression            ( LogicalOr_kw AndExpression )*
AndExpression            = BitwiseOrExpression      ( LogicalAnd_kw AndExpression )*
BitwiseOrExpression      = BitwiseXorExpression     ( BitOr_kw BitwiseOrExpression )*
BitwiseXorExpression     = BitwiseAndExpression     ( BitXor_kw BitwiseXorExpression )*
BitwiseAndExpression     = EqualityExpression       ( BitAnd_kw BitwiseAndExpression )*
EqualityExpression       = RelationalExpression     ( EqualityOperator EqualityExpression )*
RelationalExpression     = ShiftExpression          ( RelationalOperator ShiftExpression )*
ShiftExpression          = AdditiveExpression       ( ShiftOperator ShiftExpression )*
AdditiveExpression       = MultiplicativeExpression ( AdditiveOperator MultiplicativeExpression )*
MultiplicativeExpression = UnaryExpression          ( MultiplicativeOperator UnaryExpression )*

EqualityOperator       = Identical_kw | NotIdentical_kw | Equals_kw | NotEquals_kw 
RelationalOperator     = NotLess_kw | NotGreater_kw | Greater_kw | Less_kw
ShiftOperator          = LeftShift_kw | ZeroRightShift_kw
AdditiveOperator       = Add_kw | Subtract_kw
MultiplicativeOperator = Multiply_kw | Divide_kw


UnaryExpression = (Increment_kw | Decrement_kw)  MemberExpression
                | New_kw Constructor
                | Delete_kw MemberExpression
                | MemberExpression (Increment_kw | Decrement_kw)
                | MemberExpression

Constructor = ( This_kw Dot_kw )? ConstructorCall

ConstructorCall = LABEL ( Dot_kw LABEL )* ( Open_kw ArgumentList? Close_kw )?

MemberExpression = PrimaryExpression (( Dot_kw MemberExpression ) | ( SOpen_kw Expression SClose_kw ) | ( Open_kw ArgumentList? Close_kw ))+

ArgumentList = AssignmentExpression (Comma_kw AssignmentExpression)*

PrimaryExpression = Open_kw Expression Close_kw
                  | NumberLiteral
                  | StringLiteral
                  | LABEL

# Arithmetic Operators
Add_kw        = plus          !operator Spacing { add_keyword(yyrulename); }
Subtract_kw   = minus         !operator Spacing { add_keyword(yyrulename); }
Multiply_kw   = star          !operator Spacing { add_keyword(yyrulename); }
Divide_kw     = slash         !operator Spacing { add_keyword(yyrulename); }
Modulo_kw     = percent       !operator Spacing { add_keyword(yyrulename); }
Increment_kw  = plus plus     !operator Spacing { add_keyword(yyrulename); }
Decrement_kw  = minus minus   !operator Spacing { add_keyword(yyrulename); }

# Assignment Operators
AssignmentOperator = Assign_kw   | AddTo_kw       | SubtractFrom_kw       | MultiplyIt_kw | DivideIt_kw
                   | ModuloIt_kw | LeftShiftIt_kw | SignedRightShiftIt_kw | ZeroRightShiftIt_kw
Assign_kw       = equal           !operator Spacing { add_keyword(yyrulename); }
AddTo_kw        = plus equal      !operator Spacing { add_keyword(yyrulename); }
SubtractFrom_kw = minus equal     !operator Spacing { add_keyword(yyrulename); }
MultiplyIt_kw   = star equal      !operator Spacing { add_keyword(yyrulename); }
DivideIt_kw     = slash equal     !operator Spacing { add_keyword(yyrulename); }
ModuloIt_kw     = percent equal   !operator Spacing { add_keyword(yyrulename); }
LeftShiftIt_kw  = less less equal !operator Spacing { add_keyword(yyrulename); }

SignedRightShiftIt_kw = greater greater equal         !operator Spacing { add_keyword(yyrulename); }
ZeroRightShiftIt_kw   = greater greater greater equal !operator Spacing { add_keyword(yyrulename); }

# Bitwise Operators
BitAnd_kw           = and        !operator Spacing { add_keyword(yyrulename); }
BitOr_kw            = or         !operator Spacing { add_keyword(yyrulename); }
BitXor_kw           = hat        !operator Spacing { add_keyword(yyrulename); }
BitNot_kw           = twitle     !operator Spacing { add_keyword(yyrulename); }
LeftShift_kw        = less less  !operator Spacing { add_keyword(yyrulename); }
SignedRightShift_kw = greater greater         !operator Spacing { add_keyword(yyrulename); }
ZeroRightShift_kw   = greater greater greater !operator Spacing { add_keyword(yyrulename); }


# Comparison Operators
Identical_kw    = equal equal equal !operator Spacing { add_keyword(yyrulename); }
NotIdentical_kw = bang  equal equal !operator Spacing { add_keyword(yyrulename); }
Equals_kw       = equal equal   !operator Spacing { add_keyword(yyrulename); }
NotEquals_kw    = bang equal    !operator Spacing { add_keyword(yyrulename); }
Greater_kw      = greater       !operator Spacing { add_keyword(yyrulename); }
NotGreater_kw   = less equal    !operator Spacing { add_keyword(yyrulename); }
Less_kw         = less          !operator Spacing { add_keyword(yyrulename); }
NotLess_kw      = greater equal !operator Spacing { add_keyword(yyrulename); }

# Logical Operators
LogicalAnd_kw = and and       !operator Spacing { add_keyword(yyrulename); }
LogicalOr_kw  = or or         !operator Spacing { add_keyword(yyrulename); }
LogicalNot_kw = bang          !operator Spacing { add_keyword(yyrulename); }

# Conditional Operators
Condition_kw   = question !operator Spacing { add_keyword(yyrulename); }
Alternitive_kw = colon    !operator Spacing { add_keyword(yyrulename); }

# Sequence Operator
Sequence_kw = comma !operator Spacing { add_keyword(yyrulename); }

# Special Operators
Delete_kw     = 'delete'     !LABEL Spacing { add_keyword(yyrulename); }
Function_kw   = 'function'   !LABEL Spacing { add_keyword(yyrulename); }
Get_kw        = 'get'        !LABEL Spacing { add_keyword(yyrulename); }
In_kw         = 'in'         !LABEL Spacing { add_keyword(yyrulename); }
InstanceOf_kw = 'instanceof' !LABEL Spacing { add_keyword(yyrulename); }
Let_kw        = 'let'        !LABEL Spacing { add_keyword(yyrulename); }
New_kw        = 'new'        !LABEL Spacing { add_keyword(yyrulename); }
Set_kw        = 'set'        !LABEL Spacing { add_keyword(yyrulename); }
TypeOf_kw     = 'typeof'     !LABEL Spacing { add_keyword(yyrulename); }
Void_kw       = 'void'       !LABEL Spacing { add_keyword(yyrulename); }
Yield_kw      = 'yield'      !LABEL Spacing { add_keyword(yyrulename); }

# Constructs words
Var_kw        = 'var'       !LABEL Spacing { add_keyword(yyrulename); }
If_kw         = 'if'        !LABEL Spacing { add_keyword(yyrulename); }
Else_kw       = 'else'      !LABEL Spacing { add_keyword(yyrulename); }
Switch_kw     = 'switch'    !LABEL Spacing { add_keyword(yyrulename); }
Case_kw       = 'case'      !LABEL Spacing { add_keyword(yyrulename); }
Default_kw    = 'default'   !LABEL Spacing { add_keyword(yyrulename); }
Do_kw         = 'do'        !LABEL Spacing { add_keyword(yyrulename); }
While_kw      = 'while'     !LABEL Spacing { add_keyword(yyrulename); }
For_kw        = 'for'       !LABEL Spacing { add_keyword(yyrulename); }
With_kw       = 'with'      !LABEL Spacing { add_keyword(yyrulename); }
Continue_kw   = 'continue'  !LABEL Spacing { add_keyword(yyrulename); }
Break_kw      = 'break'     !LABEL Spacing { add_keyword(yyrulename); }
Return_kw     = 'return'    !LABEL Spacing { add_keyword(yyrulename); }
Throw_kw      = 'throw'     !LABEL Spacing { add_keyword(yyrulename); }
Try_kw        = 'try'       !LABEL Spacing { add_keyword(yyrulename); }
Catch_kw      = 'catch'     !LABEL Spacing { add_keyword(yyrulename); }
Finally_kw    = 'finally'   !LABEL Spacing { add_keyword(yyrulename); }

# Other words
This_kw = 'this' !LABEL Spacing { add_keyword(yyrulename); }



Begin_kw  = copen  Spacing
End_kw    = cclose Spacing
Open_kw   = popen  Spacing
Close_kw  = pclose Spacing
SOpen_kw  = sopen  Spacing
SClose_kw = sclose Spacing
Dot_kw    = dot Spacing
Comma_kw  = comma Spacing
Semi_kw   = semicolon Spacing

StringLiteral = squote < ( !squote char )* > squote Spacing
              | dquote < ( !dquote char )* > dquote Spacing

NumberLiteral = < digit+ ( dot digit+ )? > Spacing

LABEL = %begin { int hold_debug = do_debug; do_debug = 0; }
           letter | digit | underline
        %end { do_debug = hold_debug; }

Spacing = %begin { int hold_debug = do_debug; do_debug = 0; }
             (Space | LineComment | BlockComment)*
          %end { do_debug = hold_debug; }

Space        = ' ' | '\t' | EndOfLine
LineComment  = '//' (!EndOfLine .)*
BlockComment = BeginComment (!EndComment .)* EndComment
BeginComment = '/' '*'
EndComment   = '*' '/'

EndOfLine = '\r\n' | '\n' | '\r'

letter    = [a-zA-Z]
digit     = [0-9]
operator  = plus | minus | star | slash | equal | bang | or | and | less | greater | percent | question | colon | hat | twitle
plus      = '+'
minus     = '-'
star      = '*'
slash     = '/'
equal     = '='
bang      = '!'
or        = '|'
and       = '&'
less      = '<'
greater   = '>'
percent   = '%'
question  = '?'
colon     = ':'
hat       = '^'
twitle    = '~'
underline = '_'

dot       = '.'
popen     = '('
pclose    = ')'
sopen     = '['
sclose    = ']'
copen     = '{'
cclose    = '}'
at        = '@'
dollor    = '$'
comma     = ','
semicolon = ';'
squote    = [']
dquote    = ["]
bslash    = '\\'

char = bslash [abefnrtv'"\[\]\\/]
     | bslash dollor
     | bslash [0-3][0-7][0-7]
     | bslash [0-7][0-7]?
     | !bslash .

%%

void yyerror(char *message)
{
  fprintf(stderr, "%s: %s", fileName, message);
  if (yytext[0]) fprintf(stderr, " near token '%s'", yytext);
  if (yypos < yylimit || !feof(input))
    {
      yybuf[yylimit]= '\0';
      fprintf(stderr, " before text \"");
      while (yypos < yylimit)
        {
          if ('\n' == yybuf[yypos] || '\r' == yybuf[yypos]) break;
          fputc(yybuf[yypos++], stderr);
        }
      if (yypos == yylimit)
        {
          int c;
          while (EOF != (c= fgetc(input)) && '\n' != c && '\r' != c)
            fputc(c, stderr);
        }
      fputc('\"', stderr);
    }
  fprintf(stderr, "\n");
  exit(1);
}

static void usage(char *name)
{
  fprintf(stderr, "usage: %s [<option>...] [<file>...]\n", name);
  fprintf(stderr, "where <option> can be\n");
  fprintf(stderr, "  -h          print this help information\n");
  fprintf(stderr, "  -o <ofile>  write output to <ofile>\n");
  fprintf(stderr, "  -v          be verbose\n");
  fprintf(stderr, "if no <file> is given, input is read from stdin\n");
  fprintf(stderr, "if no <ofile> is given, output is written to stdout\n");
  exit(1);
}

static void doOpen(char* name)
{
  if (!(input= fopen(name, "r"))) {
    perror(name);
    exit(1);
  }

  fileName = name;
}

static void doParse()
{
  int value = 0;
  value = yyparse();
  printf("result = %d\n", value);
}

static void doClose()
{
  fclose(input);
}

int main(int argc, char **argv)
{
  int   c;
  output      = stdout;
  input       = stdin;
  fileName    = "<stdin>";

  while (-1 != (c= getopt(argc, argv, "ho:v")))
    {
      switch (c)
        {
        case 'h':
          usage(argv[0]);
          break;

        case 'v':
          ++do_debug;
          break;

        case 'o':
          if (!(output= fopen(optarg, "w")))
            {
              perror(optarg);
              exit(1);
            }
          break;

        default:
          fprintf(stderr, "for usage try: %s -h\n", argv[0]);
          exit(1);
        }
    }

  argc -= optind;
  argv += optind;

  if (!argc) {
    doParse();
    return 0;
  }

  for (;  argc;  --argc, ++argv) {
    if (!strcmp(*argv, "-")) {
      input    = stdin;
      fileName = "<stdin>";
      doParse();
      continue;
    }

    doOpen(*argv);
    doParse();
    doClose();
  }

  return 0;
}
