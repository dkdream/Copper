/* A recursive-descent parser generated by copper 1.1.0 */

/*-*- mode: c;-*-*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct _yyclass  YYClass;
typedef struct _yystack  YYStack;
typedef struct _yystate  YYState;
typedef struct _yythunk  YYThunk;
typedef struct _yycache  YYCache;
typedef unsigned         YYArgument;

typedef int  (*YYRule)(YYClass* yySelf, YYStack* stack);
typedef void (*YYAction)(YYClass* yySelf, YYThunk thunk);

typedef int  (*YYInput)(YYClass* yySelf, char* buffer, int max_size);
typedef void (*YYDebug)(YYClass* yySelf, const char* format, ...);
typedef void (*YYMark)(YYClass* yySelf);
typedef void (*YYCollect)(YYClass* yySelf);

#ifndef YYSTYPE
#define YYSTYPE	int
#endif

struct  _yyclass {
    char *    buf;
    int	      buflen;
    int	      pos;
    int	      limit;
    char *    text;
    int	      textlen;
    int	      begin;
    int	      end;
    int	      textmax;

    /* action list */
    YYThunk * thunks;
    int	      thunkslen;
    int       thunkpos;

    /* data stack */
    YYSTYPE   result;
    int       val;
    YYSTYPE * vals;
    int       valslen;

    /**/
    YYCache * cache;

    /*method table*/
    YYInput   input_;
    YYDebug   debug_;
    YYMark    mark_;
    YYCollect collect_;
};

/*-- end of header --*/

#define YYRULECOUNT 40

#include "copper.inc"

/*-*- mode: c;-*-*/

#define YY_SAVE(state)    { state.pos = yySelf->pos; state.thunkpos = yySelf->thunkpos; }
#define YY_RESTORE(state) { yySelf->pos = state.pos; yySelf->thunkpos = state.thunkpos; }

#ifndef YY_DEBUG
#ifndef DEBUGGING
#define YY_DEBUG(format, args...)
#else
#define YY_DEBUG(format, args...) fprintf(stderr, format, ## args)
#endif
#endif

#ifndef YY_INPUT
#define YY_INPUT(buf, max_size)	yynextchar(buf, max_size)
static inline int yynextchar(char* buffer, int max_size) {
    int yyc = getchar();
    if (EOF == yyc) return 0;
    buffer[0] = yyc;
    return 1;
}
#endif

/* begin of yytext */
#define YY_BEGIN ( yySelf->begin = yySelf->pos, yySelf->end = yySelf->pos, 1)

/* end of yytext */
#define YY_END (yySelf->end = yySelf->pos, 1)

/* user defined mark (useful in marking parse stack) */
#ifndef YY_MARK
#define YY_MARK
#endif

/* user defined collect (useful in collecting from a parse stack) */
#ifndef YY_COLLECT
#define YY_COLLECT
#endif

#ifndef YY_CACHE_SLOTS
#define YY_CACHE_SLOTS 1023
#endif

#ifndef YY_CACHE_THUNKS
#define YY_CACHE_THUNKS 10
#endif

#ifndef YY_PART

typedef struct _yycache_node YYCacheNode;

struct _yystate {
    int pos;
    int thunkpos;
};

struct _yystack {
    YYStack*    next;
    const char* name;
    YYRule      current;
    YYState     begin;
};

struct _yythunk {
    int        begin;
    int        end;
    YYState    state;
    YYAction   action;
    YYArgument argument;
};

struct _yycache_node {
    YYCacheNode* next;
    int     location;
    void*   function;
    int     result;
    int     pos;
    int     begin;
    int     end;
    int     count;
    YYThunk thunk[0];
};

struct _yycache {
    int size;
    YYCacheNode* slot[0];
};

static YYClass theParser;

static void save_method(YYClass* yySelf, YYState* state) {
    state->pos = yySelf->pos; state->thunkpos = yySelf->thunkpos;
}

static void restore_method(YYClass* yySelf, YYState* state) {
    yySelf->pos = state->pos; yySelf->thunkpos = state->thunkpos;
}

static int input_method(YYClass* yySelf, char* buffer, int max_size) {
    int yyc = getchar();
    if (EOF == yyc) return 0;
    buffer[0] = yyc;
    return 1;
}

static inline void yyInit(YYClass* yySelf) {
    yySelf->buf       = 0;
    yySelf->buflen    = 0;
    yySelf->pos       = 0;
    yySelf->limit     = 0;
    yySelf->text      = 0;
    yySelf->textlen   = 0;
    yySelf->begin     = 0;
    yySelf->end       = 0;
    yySelf->textmax   = 0;
    yySelf->thunks    = 0;
    yySelf->thunkslen = 0;
    yySelf->thunkpos  = 0;
    yySelf->val       = 0;
    yySelf->vals      = 0;
    yySelf->valslen   = 0;
    yySelf->cache     = 0;
}

static inline void yyStart(YYClass* yySelf) {
    if (yySelf->buflen) return;

    yySelf->buflen    = 1024;
    yySelf->buf       = malloc(yySelf->buflen);
    yySelf->textlen   = 1024;
    yySelf->text      = malloc(yySelf->textlen);
    yySelf->thunkslen = 32;
    yySelf->thunks    = malloc(sizeof(YYThunk) * yySelf->thunkslen);
    yySelf->valslen   = 32;
    yySelf->vals      = malloc(sizeof(YYSTYPE) * yySelf->valslen);
    yySelf->begin     = yySelf->end = yySelf->pos = yySelf->limit = yySelf->thunkpos = 0;
    yySelf->text[0]   = '\0';
    yySelf->val       = 0;
}

static inline void yyFreeList(YYCacheNode* node) {
    YYCacheNode* next = 0;
    for (; node; node = next) {
        next = node->next;
        free(node);
    }
}

static inline void yyClearCache(YYClass* yySelf) {
    YY_DEBUG("     yyClearCache\n");
    if (!yySelf->cache) {
        yySelf->cache = malloc(sizeof(struct _yycache) + (sizeof(YYCacheNode*) * YY_CACHE_SLOTS));
        yySelf->cache->size = YY_CACHE_SLOTS;
        int size = yySelf->cache->size;
        for (; size--;) {
            yySelf->cache->slot[size] = 0;
        }
    } else {
        int size = yySelf->cache->size;
        for (; size--;) {
            YYCacheNode* node = yySelf->cache->slot[size];
            yyFreeList(node);
            yySelf->cache->slot[size] = 0;
        }
    }
}

static inline void yyResizeDo(YYClass* yySelf, int count) {
    while ((yySelf->thunkpos + count) >= yySelf->thunkslen) {
        yySelf->thunkslen *= 2;
        yySelf->thunks     = realloc(yySelf->thunks, sizeof(YYThunk) * yySelf->thunkslen);
    }
}

static inline void yyAddNode(YYClass* yySelf, YYStack *yystack, int result) {
    if (!yySelf->cache) return;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int count = 0;

    if (result) {
        // if no chars are consumed then
        // this may the result of a YYACCEPT not of an optional rule
        // -- skip it
        if (start.pos == yySelf->pos) return;

        // if no thunks were added then check check the length
        if (start.thunkpos != yySelf->thunkpos) {
            count = yySelf->thunkpos - start.thunkpos;
            // wrong direction
            if (0 > count) return;
            // to many
            if (YY_CACHE_THUNKS < count) {
                YY_DEBUG("     not adding cache node (%s,@%d,%d) at %d for %s - to many thunks\n",
                         (result ? "ok" : "fail"), yySelf->pos, count,
                         start.pos, name);
                return;
            }
            // return;
        }
    }

    int index = start.pos % yySelf->cache->size;

    YYCacheNode* node =  malloc(sizeof(YYCacheNode) + (sizeof(YYCacheNode) * count));

    if (!node) return;

    node->next     = yySelf->cache->slot[index];
    node->location = start.pos;
    node->function = function;
    node->result   = result;
    node->begin    = yySelf->begin;
    node->end      = yySelf->end;

    if (result) {
        node->pos = yySelf->pos;
        node->count = count;
        YYThunk* to   = &(node->thunk[0]);
        YYThunk* from = &(yySelf->thunks[start.thunkpos]);
        for (; count--; ++to, ++from) {
            *to = *from;
        }
    } else {
        node->pos = start.pos;
        node->count = 0;
    }

    YY_DEBUG("     adding cache node (%s,@%d,%d) at %d for %s\n",
             (node->result ? "ok" : "fail"), node->pos, node->count,
             node->location, name);

    yySelf->cache->slot[index] = node;
}

static inline int yyCheckNode(YYClass* yySelf, YYStack *yystack, int* result)
{
    if (!yySelf->cache) return 0;

    const char* name = yystack->name;
    YYRule  function = yystack->current;
    YYState    start = yystack->begin;

    int index = start.pos % yySelf->cache->size;

    YYCacheNode* node = yySelf->cache->slot[index];

    for (; node; node = node->next) {
        if (node->location != start.pos) continue;
        if (node->function != function) continue;
        *result = node->result;
        yySelf->pos   = node->pos;
        yySelf->begin = node->begin;
        yySelf->end   = node->end;

        int count = node->count;

        YYThunk* from = &(node->thunk[0]);
        YYThunk* to   = &(yySelf->thunks[yySelf->thunkpos]);

        if (0 < count) {
            yyResizeDo(yySelf, count);
            yySelf->thunkpos += count;
            for (; count--; ++to, ++from) {
                *to = *from;
            }
        }

        YY_DEBUG("     using cache node (%s,@%d,%d) at %d for %s\n",
                 (node->result ? "ok" : "fail"), node->pos, node->count,
                 node->location, name);

        return 1;
    }

    return 0;
}

static inline int yyrefill(YYClass* yySelf) {
    YY_DEBUG("     yyrefill\n");

    if (yySelf->buflen - yySelf->pos < 512) {
        while (yySelf->buflen - yySelf->pos < 512) {
            yySelf->buflen *= 2;
            yySelf->buf     = realloc(yySelf->buf, yySelf->buflen+2);
        }
        yySelf->buf[yySelf->limit] = 0;
    }

    int yyn = YY_INPUT(yySelf->buf + yySelf->pos, yySelf->buflen - yySelf->pos);

    if (0 == yyn) return 0;

    yySelf->limit += yyn;
    yySelf->buf[yySelf->limit] = 0;

    return 1;
}

static inline int yymatchDot(YYClass* yySelf) {
    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;
    yySelf->pos += 1;
    return 1;
}

static inline int yymatchChar(YYClass* yySelf, int c) {
    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

    if (yySelf->buf[yySelf->pos] == c) {
        yySelf->pos += 1;
        return 1;
    }

    return 0;
}

static inline int yymatchString(YYClass* yySelf, char *s) {
    int yysav= yySelf->pos;
    while (*s) {
        if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) {
            yySelf->pos= yysav;
            return 0;
        }
        if (yySelf->buf[yySelf->pos] != *s) {
            yySelf->pos= yysav;
            return 0;
        }
        ++s;
        yySelf->pos += 1;
    }
    return 1;
}

static inline int yymatchClass(YYClass* yySelf, const char* cls, unsigned char *bits) {
    int chr;

    if (yySelf->pos >= yySelf->limit && !yyrefill(yySelf)) return 0;

    chr = yySelf->buf[yySelf->pos];

    if (bits[chr >> 3] & (1 << (chr & 7))) {
        ++yySelf->pos;
        return 1;
    }

    return 0;
}

static inline void yyDo(YYClass* yySelf, YYAction action, YYArgument arg, YYState state) {

    yyResizeDo(yySelf,1);

    YYThunk *thunk = &(yySelf->thunks[yySelf->thunkpos]);

    thunk->begin    = yySelf->begin;
    thunk->end      = yySelf->end;
    thunk->state    = state;
    thunk->action   = action;
    thunk->argument = arg;

    ++yySelf->thunkpos;
}

static int yyBegin(YYClass* yySelf) {
    yySelf->begin = yySelf->pos;
    yySelf->end   = yySelf->pos;

    YY_DEBUG("BEGIN %d\n", yySelf->begin);

    return 1;
}

static inline int yyText(YYClass* yySelf) {
    int begin  = yySelf->begin;
    int end    = yySelf->end;
    int length = end - begin;

    if (length <= 0)
        length = 0;
    else {
        int   textlen = yySelf->textlen;
        char* text    = yySelf->text;

        if (textlen < (length - 1)) {
            while (textlen < (length - 1)) {
                textlen *= 2;
                text= realloc(text, textlen);
            }

            yySelf->textlen = textlen;
            yySelf->text    = text;
        }

        memcpy(text, yySelf->buf + begin, length);
    }

    yySelf->text[length]= '\0';

    //    YY_DEBUG("GET text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

    return length;
}

static int yyEnd(YYClass* yySelf) {
    yySelf->end = yySelf->pos;

    int length = yyText(yySelf);

    if (0 < length) {
        YY_DEBUG("END %d \'%s\'\n", yySelf->end, yySelf->text);
    } else {
        YY_DEBUG("END %d\n", yySelf->end);
    }

    return 1;
}

static inline int yyThunkText(YYClass* yySelf, YYThunk thunk) {
    int begin  = thunk.begin;
    int end    = thunk.end;
    int length = end - begin;

    if (length <= 0)
        length = 0;
    else {
        char* target = yySelf->text;
        char* source = yySelf->buf + begin;
        int   limit  = yySelf->textlen;

        if (limit < (length - 1)) {
            while (limit < (length - 1)) {
                limit *= 2;
                target= realloc(target, limit);
            }

            yySelf->textlen = limit;
            yySelf->text    = target;
        }

        memcpy(target, source, length);
    }

    yySelf->text[length]= '\0';

    //    YY_DEBUG("GET thunk text[%d,%d] = \'%s\'\n", begin, end,  yySelf->text);

    return length;
}

static inline void yyDone(YYClass* yySelf) {
    int pos;
    for (pos = 0;  pos < yySelf->thunkpos;  ++pos) {
        YYThunk *thunk = &yySelf->thunks[pos];

        YY_DEBUG("DO [%d] %p : ", pos, thunk->action);

        thunk->action(yySelf, yySelf->thunks[pos]);
    }
    yySelf->thunkpos = 0;
}

static inline void yyCommit(YYClass* yySelf) {

    if ((yySelf->limit -= yySelf->pos)) {
        memmove(yySelf->buf, yySelf->buf + yySelf->pos, yySelf->limit);
    }

    yySelf->buf[yySelf->limit] = 0;

    yySelf->begin -= yySelf->pos;
    yySelf->end   -= yySelf->pos;

    if (0 > yySelf->begin) yySelf->begin = 0;
    if (0 > yySelf->end)   yySelf->end = 0;

    yySelf->pos = yySelf->thunkpos = 0;

    yyClearCache(yySelf);
}

static inline int yyAccept(YYClass* yySelf, YYStack* yystack) {
    int tp0 = yystack->begin.thunkpos;

    if (tp0) {
        fprintf(stderr, "accept denied at %d", tp0);
        return 0;
    } else {
        YY_DEBUG("    yyAccept begin\n");
        yyDone(yySelf);
        yyCommit(yySelf);
        YY_DEBUG("    yyAccept end\n");
    }
    return 1;
}

static void yyPush(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s %d\n", "push", thunk.argument);
    /* need to check if yySelf->val > yySelf->valslen */
    yySelf->val += thunk.argument;
}

static void yyPop(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s %d\n", "pop", thunk.argument);
    yySelf->val -= thunk.argument;
    /* need to check if yySelf->val < 0 */
}

static void yySet(YYClass* yySelf, YYThunk thunk) {
    YY_DEBUG("do %s v[%d] = %d\n", "set", thunk.argument,  yySelf->result);
    yySelf->vals[yySelf->val + thunk.argument] = yySelf->result;
}

static int yyCall(YYClass* yySelf, YYStack* yystack, YYRule function, const char* name) {
    YYStack yytop;
    YYState yystate;

    yytop.next    = yystack;
    yytop.current = function;
    yytop.name    = name;

    YY_SAVE(yytop.begin);

    YY_DEBUG("start(%i) %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);

    int result;

    if (yyCheckNode(yySelf, &yytop, &result)) {
        return result;
    } else {
        result = function(yySelf, &yytop);
    }

    yyAddNode(yySelf, &yytop, result);

    if (result) {
        YY_DEBUG("  ok(%i)   %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);
    } else {
        YY_DEBUG("  fail(%i) %s @ %s\n", yytop.begin.pos, name, yySelf->buf+yytop.begin.pos);
        YY_RESTORE(yytop.begin);
    }

    return result;
}

#endif /* YY_PART */

#define	YYACCEPT yyAccept(yySelf, yystack)

/*-- end of preamble --*/

/* rules */
static int yy_end_of_line (YYClass* yySelf, YYStack* yystack); /* 40 */
static int yy_comment (YYClass* yySelf, YYStack* yystack); /* 39 */
static int yy_space (YYClass* yySelf, YYStack* yystack); /* 38 */
static int yy_braces (YYClass* yySelf, YYStack* yystack); /* 37 */
static int yy_range (YYClass* yySelf, YYStack* yystack); /* 36 */
static int yy_char (YYClass* yySelf, YYStack* yystack); /* 35 */
static int yy_COLLECT (YYClass* yySelf, YYStack* yystack); /* 34 */
static int yy_MARK (YYClass* yySelf, YYStack* yystack); /* 33 */
static int yy_END (YYClass* yySelf, YYStack* yystack); /* 32 */
static int yy_BEGIN (YYClass* yySelf, YYStack* yystack); /* 31 */
static int yy_DOT (YYClass* yySelf, YYStack* yystack); /* 30 */
static int yy_class (YYClass* yySelf, YYStack* yystack); /* 29 */
static int yy_literal (YYClass* yySelf, YYStack* yystack); /* 28 */
static int yy_CLOSE (YYClass* yySelf, YYStack* yystack); /* 27 */
static int yy_OPEN (YYClass* yySelf, YYStack* yystack); /* 26 */
static int yy_COLON (YYClass* yySelf, YYStack* yystack); /* 25 */
static int yy_PLUS (YYClass* yySelf, YYStack* yystack); /* 24 */
static int yy_STAR (YYClass* yySelf, YYStack* yystack); /* 23 */
static int yy_QUESTION (YYClass* yySelf, YYStack* yystack); /* 22 */
static int yy_primary (YYClass* yySelf, YYStack* yystack); /* 21 */
static int yy_NOT (YYClass* yySelf, YYStack* yystack); /* 20 */
static int yy_suffix (YYClass* yySelf, YYStack* yystack); /* 19 */
static int yy_AND (YYClass* yySelf, YYStack* yystack); /* 18 */
static int yy_prefix (YYClass* yySelf, YYStack* yystack); /* 17 */
static int yy_BAR (YYClass* yySelf, YYStack* yystack); /* 16 */
static int yy_sequence (YYClass* yySelf, YYStack* yystack); /* 15 */
static int yy_action (YYClass* yySelf, YYStack* yystack); /* 14 */
static int yy_SEMICOLON (YYClass* yySelf, YYStack* yystack); /* 13 */
static int yy_begin (YYClass* yySelf, YYStack* yystack); /* 12 */
static int yy_end (YYClass* yySelf, YYStack* yystack); /* 11 */
static int yy_expression (YYClass* yySelf, YYStack* yystack); /* 10 */
static int yy_EQUAL (YYClass* yySelf, YYStack* yystack); /* 9 */
static int yy_identifier (YYClass* yySelf, YYStack* yystack); /* 8 */
static int yy_RPERCENT (YYClass* yySelf, YYStack* yystack); /* 7 */
static int yy_end_of_file (YYClass* yySelf, YYStack* yystack); /* 6 */
static int yy_trailer (YYClass* yySelf, YYStack* yystack); /* 5 */
static int yy_definition (YYClass* yySelf, YYStack* yystack); /* 4 */
static int yy_declaration (YYClass* yySelf, YYStack* yystack); /* 3 */
static int yy__ (YYClass* yySelf, YYStack* yystack); /* 2 */
static int yy_grammar (YYClass* yySelf, YYStack* yystack); /* 1 */

/* actions */
static void yy_11_primary (YYClass* yySelf, YYThunk thunk);
static void yy_10_primary (YYClass* yySelf, YYThunk thunk);
static void yy_9_primary (YYClass* yySelf, YYThunk thunk);
static void yy_8_primary (YYClass* yySelf, YYThunk thunk);
static void yy_7_primary (YYClass* yySelf, YYThunk thunk);
static void yy_6_primary (YYClass* yySelf, YYThunk thunk);
static void yy_5_primary (YYClass* yySelf, YYThunk thunk);
static void yy_4_primary (YYClass* yySelf, YYThunk thunk);
static void yy_3_primary (YYClass* yySelf, YYThunk thunk);
static void yy_2_primary (YYClass* yySelf, YYThunk thunk);
static void yy_1_primary (YYClass* yySelf, YYThunk thunk);
static void yy_3_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_2_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_1_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_3_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_2_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_1_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_1_sequence (YYClass* yySelf, YYThunk thunk);
static void yy_1_expression (YYClass* yySelf, YYThunk thunk);
static void yy_1_end (YYClass* yySelf, YYThunk thunk);
static void yy_1_begin (YYClass* yySelf, YYThunk thunk);
static void yy_5_definition (YYClass* yySelf, YYThunk thunk);
static void yy_4_definition (YYClass* yySelf, YYThunk thunk);
static void yy_3_definition (YYClass* yySelf, YYThunk thunk);
static void yy_2_definition (YYClass* yySelf, YYThunk thunk);
static void yy_1_definition (YYClass* yySelf, YYThunk thunk);
static void yy_1_trailer (YYClass* yySelf, YYThunk thunk);
static void yy_1_declaration (YYClass* yySelf, YYThunk thunk);

static void yy_11_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_11_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction("YY_COLLECT;")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_10_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_10_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction("YY_MARK;")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_9_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_9_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeMark("YY_END")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_8_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_8_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeMark("YY_BEGIN")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_7_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_7_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_6_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_6_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeDot()); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_5_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_5_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeClass(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_4_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_4_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeString(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_3_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_3_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeName(findRule(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_2_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_2_primary (%s) '%s'\n", yyrulename, yytext);

   Node *name= makeName(findRule(yytext));  name->name.variable= pop();  push(name); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeVariable(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_3_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_3_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makePlus (pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_2_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_2_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makeStar (pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makeQuery(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_3_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_3_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePeekNot(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_2_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_2_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePeekFor(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePredicate(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_sequence(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "sequence";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_sequence (%s) '%s'\n", yyrulename, yytext);

   Node *f= pop();  push(Sequence_append(pop(), f)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_expression(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "expression";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_expression (%s) '%s'\n", yyrulename, yytext);

   Node *f= pop();  push(Alternate_append(pop(), f)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_end(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "end";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_end (%s) '%s'\n", yyrulename, yytext);

   push(makePredicate(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_begin(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "begin";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_begin (%s) '%s'\n", yyrulename, yytext);

   push(makePredicate(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_5_definition(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "definition";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_5_definition (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_begin); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_4_definition(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "definition";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_4_definition (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_both); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_3_definition(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "definition";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_3_definition (%s) '%s'\n", yyrulename, yytext);

   defineRule(simple_rule); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_2_definition(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "definition";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_2_definition (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_end); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_definition(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "definition";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_definition (%s) '%s'\n", yyrulename, yytext);

   checkRule(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_trailer(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "trailer";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_trailer (%s) '%s'\n", yyrulename, yytext);

   makeTrailer(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}
static void yy_1_declaration(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "declaration";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->pos;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  YY_DEBUG("do yy_1_declaration (%s) '%s'\n", yyrulename, yytext);

   makeHeader(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
}

static int yy_end_of_line(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end_of_line";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate2;
  YY_SAVE(yystate2);  if (!yymatchString(yySelf, "\r\n")) goto l3; goto l2;
  l3:;	
  YY_RESTORE(yystate2);  if (!yymatchChar(yySelf, '\n')) goto l4; goto l2;
  l4:;	
  YY_RESTORE(yystate2);  if (!yymatchChar(yySelf, '\r')) goto failed;
  l2:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_comment(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "comment";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '#')) goto failed;
  l5:;	
  YYState yystate6;
  YY_SAVE(yystate6);
  YYState yystate7;
  YY_SAVE(yystate7);  if (!yyCall(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto l7; goto l6;
  l7:;	
  YY_RESTORE(yystate7);  if (!yymatchDot(yySelf)) goto l6; goto l5;
  l6:;	
  YY_RESTORE(yystate6);  if (!yyCall(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_space(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "space";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate8;
  YY_SAVE(yystate8);  if (!yymatchChar(yySelf, ' ')) goto l9; goto l8;
  l9:;	
  YY_RESTORE(yystate8);  if (!yymatchChar(yySelf, '\t')) goto l10; goto l8;
  l10:;	
  YY_RESTORE(yystate8);  if (!yyCall(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto failed;
  l8:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_braces(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "braces";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate11;
  YY_SAVE(yystate11);  if (!yymatchChar(yySelf, '{')) goto l12;
  l13:;	
  YYState yystate14;
  YY_SAVE(yystate14);
  YYState yystate15;
  YY_SAVE(yystate15);  if (!yymatchChar(yySelf, '}')) goto l15; goto l14;
  l15:;	
  YY_RESTORE(yystate15);  if (!yymatchDot(yySelf)) goto l14; goto l13;
  l14:;	
  YY_RESTORE(yystate14);  if (!yymatchChar(yySelf, '}')) goto l12; goto l11;
  l12:;	
  YY_RESTORE(yystate11);
  YYState yystate16;
  YY_SAVE(yystate16);  if (!yymatchChar(yySelf, '}')) goto l16; goto failed;
  l16:;	
  YY_RESTORE(yystate16);  if (!yymatchDot(yySelf)) goto failed;
  l11:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_range(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "range";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate17;
  YY_SAVE(yystate17);  if (!yyCall(yySelf, yystack, &yy_char, "char")) goto l18;  if (!yymatchChar(yySelf, '-')) goto l18;  if (!yyCall(yySelf, yystack, &yy_char, "char")) goto l18; goto l17;
  l18:;	
  YY_RESTORE(yystate17);  if (!yyCall(yySelf, yystack, &yy_char, "char")) goto failed;
  l17:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_char(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "char";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate19;
  YY_SAVE(yystate19);  if (!yymatchChar(yySelf, '\\')) goto l20;  if (!yymatchClass(yySelf, "abefnrtv\'\"\\[\\]\\\\", (unsigned char *)"\000\000\000\000\204\000\000\000\000\000\000\070\146\100\124\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l20; goto l19;
  l20:;	
  YY_RESTORE(yystate19);  if (!yymatchChar(yySelf, '\\')) goto l21;  if (!yymatchClass(yySelf, "0-3", (unsigned char *)"\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21; goto l19;
  l21:;	
  YY_RESTORE(yystate19);  if (!yymatchChar(yySelf, '\\')) goto l22;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l22;
  YYState yystate23;
  YY_SAVE(yystate23);  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l23; goto l24;
  l23:;	
  YY_RESTORE(yystate23);
  l24:;	 goto l19;
  l22:;	
  YY_RESTORE(yystate19);
  YYState yystate25;
  YY_SAVE(yystate25);  if (!yymatchChar(yySelf, '\\')) goto l25; goto failed;
  l25:;	
  YY_RESTORE(yystate25);  if (!yymatchDot(yySelf)) goto failed;
  l19:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_COLLECT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "COLLECT";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '$')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_MARK(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "MARK";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '@')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_END(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "END";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '>')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_BEGIN(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "BEGIN";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '<')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_DOT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "DOT";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '.')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_class(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "class";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '[')) goto failed;  { YY_BEGIN; }
  l26:;	
  YYState yystate27;
  YY_SAVE(yystate27);
  YYState yystate28;
  YY_SAVE(yystate28);  if (!yymatchChar(yySelf, ']')) goto l28; goto l27;
  l28:;	
  YY_RESTORE(yystate28);  if (!yyCall(yySelf, yystack, &yy_range, "range")) goto l27; goto l26;
  l27:;	
  YY_RESTORE(yystate27);  { YY_END; }  if (!yymatchChar(yySelf, ']')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_literal(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "literal";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate29;
  YY_SAVE(yystate29);  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l30;  { YY_BEGIN; }
  l31:;	
  YYState yystate32;
  YY_SAVE(yystate32);
  YYState yystate33;
  YY_SAVE(yystate33);  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l33; goto l32;
  l33:;	
  YY_RESTORE(yystate33);  if (!yyCall(yySelf, yystack, &yy_char, "char")) goto l32; goto l31;
  l32:;	
  YY_RESTORE(yystate32);  { YY_END; }  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l30;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto l30; goto l29;
  l30:;	
  YY_RESTORE(yystate29);  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;  { YY_BEGIN; }
  l34:;	
  YYState yystate35;
  YY_SAVE(yystate35);
  YYState yystate36;
  YY_SAVE(yystate36);  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l36; goto l35;
  l36:;	
  YY_RESTORE(yystate36);  if (!yyCall(yySelf, yystack, &yy_char, "char")) goto l35; goto l34;
  l35:;	
  YY_RESTORE(yystate35);  { YY_END; }  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  l29:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_CLOSE(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "CLOSE";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, ')')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_OPEN(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "OPEN";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '(')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_COLON(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "COLON";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, ':')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_PLUS(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "PLUS";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '+')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_STAR(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "STAR";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '*')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_QUESTION(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "QUESTION";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '?')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_primary(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "primary";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate37;
  YY_SAVE(yystate37);  if (!yyCall(yySelf, yystack, &yy_identifier, "identifier")) goto l38;  yyDo(yySelf, yy_1_primary, 0, yystate0);  if (!yyCall(yySelf, yystack, &yy_COLON, "COLON")) goto l38;  if (!yyCall(yySelf, yystack, &yy_identifier, "identifier")) goto l38;
  YYState yystate39;
  YY_SAVE(yystate39);  if (!yyCall(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto l39; goto l38;
  l39:;	
  YY_RESTORE(yystate39);  yyDo(yySelf, yy_2_primary, 0, yystate0); goto l37;
  l38:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_identifier, "identifier")) goto l40;
  YYState yystate41;
  YY_SAVE(yystate41);  if (!yyCall(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto l41; goto l40;
  l41:;	
  YY_RESTORE(yystate41);  yyDo(yySelf, yy_3_primary, 0, yystate0); goto l37;
  l40:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_OPEN, "OPEN")) goto l42;  if (!yyCall(yySelf, yystack, &yy_expression, "expression")) goto l42;  if (!yyCall(yySelf, yystack, &yy_CLOSE, "CLOSE")) goto l42; goto l37;
  l42:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_literal, "literal")) goto l43;  yyDo(yySelf, yy_4_primary, 0, yystate0); goto l37;
  l43:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_class, "class")) goto l44;  yyDo(yySelf, yy_5_primary, 0, yystate0); goto l37;
  l44:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_DOT, "DOT")) goto l45;  yyDo(yySelf, yy_6_primary, 0, yystate0); goto l37;
  l45:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_action, "action")) goto l46;  yyDo(yySelf, yy_7_primary, 0, yystate0); goto l37;
  l46:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_BEGIN, "BEGIN")) goto l47;  yyDo(yySelf, yy_8_primary, 0, yystate0); goto l37;
  l47:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_END, "END")) goto l48;  yyDo(yySelf, yy_9_primary, 0, yystate0); goto l37;
  l48:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_MARK, "MARK")) goto l49;  yyDo(yySelf, yy_10_primary, 0, yystate0); goto l37;
  l49:;	
  YY_RESTORE(yystate37);  if (!yyCall(yySelf, yystack, &yy_COLLECT, "COLLECT")) goto failed;  yyDo(yySelf, yy_11_primary, 0, yystate0);
  l37:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_NOT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "NOT";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '!')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_suffix(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "suffix";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yyCall(yySelf, yystack, &yy_primary, "primary")) goto failed;
  YYState yystate50;
  YY_SAVE(yystate50);
  YYState yystate52;
  YY_SAVE(yystate52);  if (!yyCall(yySelf, yystack, &yy_QUESTION, "QUESTION")) goto l53;  yyDo(yySelf, yy_1_suffix, 0, yystate0); goto l52;
  l53:;	
  YY_RESTORE(yystate52);  if (!yyCall(yySelf, yystack, &yy_STAR, "STAR")) goto l54;  yyDo(yySelf, yy_2_suffix, 0, yystate0); goto l52;
  l54:;	
  YY_RESTORE(yystate52);  if (!yyCall(yySelf, yystack, &yy_PLUS, "PLUS")) goto l50;  yyDo(yySelf, yy_3_suffix, 0, yystate0);
  l52:;	 goto l51;
  l50:;	
  YY_RESTORE(yystate50);
  l51:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_AND(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "AND";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '&')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_prefix(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "prefix";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate55;
  YY_SAVE(yystate55);  if (!yyCall(yySelf, yystack, &yy_AND, "AND")) goto l56;  if (!yyCall(yySelf, yystack, &yy_action, "action")) goto l56;  yyDo(yySelf, yy_1_prefix, 0, yystate0); goto l55;
  l56:;	
  YY_RESTORE(yystate55);  if (!yyCall(yySelf, yystack, &yy_AND, "AND")) goto l57;  if (!yyCall(yySelf, yystack, &yy_suffix, "suffix")) goto l57;  yyDo(yySelf, yy_2_prefix, 0, yystate0); goto l55;
  l57:;	
  YY_RESTORE(yystate55);  if (!yyCall(yySelf, yystack, &yy_NOT, "NOT")) goto l58;  if (!yyCall(yySelf, yystack, &yy_suffix, "suffix")) goto l58;  yyDo(yySelf, yy_3_prefix, 0, yystate0); goto l55;
  l58:;	
  YY_RESTORE(yystate55);  if (!yyCall(yySelf, yystack, &yy_suffix, "suffix")) goto failed;
  l55:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_BAR(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "BAR";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '|')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_sequence(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "sequence";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yyCall(yySelf, yystack, &yy_prefix, "prefix")) goto failed;
  l59:;	
  YYState yystate60;
  YY_SAVE(yystate60);  if (!yyCall(yySelf, yystack, &yy_prefix, "prefix")) goto l60;  yyDo(yySelf, yy_1_sequence, 0, yystate0); goto l59;
  l60:;	
  YY_RESTORE(yystate60);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_action(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "action";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '{')) goto failed;  { YY_BEGIN; }
  l61:;	
  YYState yystate62;
  YY_SAVE(yystate62);  if (!yyCall(yySelf, yystack, &yy_braces, "braces")) goto l62; goto l61;
  l62:;	
  YY_RESTORE(yystate62);  { YY_END; }  if (!yymatchChar(yySelf, '}')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_SEMICOLON(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "SEMICOLON";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, ';')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_begin(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "begin";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchString(yySelf, "%begin")) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;  if (!yyCall(yySelf, yystack, &yy_action, "action")) goto failed;  yyDo(yySelf, yy_1_begin, 0, yystate0);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_end(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchString(yySelf, "%end")) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;  if (!yyCall(yySelf, yystack, &yy_action, "action")) goto failed;  yyDo(yySelf, yy_1_end, 0, yystate0);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_expression(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "expression";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yyCall(yySelf, yystack, &yy_sequence, "sequence")) goto failed;
  l63:;	
  YYState yystate64;
  YY_SAVE(yystate64);  if (!yyCall(yySelf, yystack, &yy_BAR, "BAR")) goto l64;  if (!yyCall(yySelf, yystack, &yy_sequence, "sequence")) goto l64;  yyDo(yySelf, yy_1_expression, 0, yystate0); goto l63;
  l64:;	
  YY_RESTORE(yystate64);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_EQUAL(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "EQUAL";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchChar(yySelf, '=')) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_identifier(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "identifier";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  { YY_BEGIN; }  if (!yymatchClass(yySelf, "-a-zA-Z_", (unsigned char *)"\000\000\000\000\000\040\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;
  l65:;	
  YYState yystate66;
  YY_SAVE(yystate66);  if (!yymatchClass(yySelf, "-a-zA-Z_0-9", (unsigned char *)"\000\000\000\000\000\040\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l66; goto l65;
  l66:;	
  YY_RESTORE(yystate66);  { YY_END; }  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_RPERCENT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "RPERCENT";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchString(yySelf, "%}")) goto failed;  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_end_of_file(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end_of_file";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  YYState yystate67;
  YY_SAVE(yystate67);  if (!yymatchDot(yySelf)) goto l67; goto failed;
  l67:;	
  YY_RESTORE(yystate67);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_trailer(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "trailer";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchString(yySelf, "%%")) goto failed;  { YY_BEGIN; }
  l68:;	
  YYState yystate69;
  YY_SAVE(yystate69);  if (!yymatchDot(yySelf)) goto l69; goto l68;
  l69:;	
  YY_RESTORE(yystate69);  { YY_END; }  yyDo(yySelf, yy_1_trailer, 0, yystate0);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_definition(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "definition";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yyCall(yySelf, yystack, &yy_identifier, "identifier")) goto failed;  yyDo(yySelf, yy_1_definition, 0, yystate0);  if (!yyCall(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto failed;
  YYState yystate70;
  YY_SAVE(yystate70);  if (!yyCall(yySelf, yystack, &yy_expression, "expression")) goto l71;  if (!yyCall(yySelf, yystack, &yy_end, "end")) goto l71;  yyDo(yySelf, yy_2_definition, 0, yystate0); goto l70;
  l71:;	
  YY_RESTORE(yystate70);  if (!yyCall(yySelf, yystack, &yy_expression, "expression")) goto l72;  yyDo(yySelf, yy_3_definition, 0, yystate0); goto l70;
  l72:;	
  YY_RESTORE(yystate70);  if (!yyCall(yySelf, yystack, &yy_begin, "begin")) goto l73;  if (!yyCall(yySelf, yystack, &yy_expression, "expression")) goto l73;  if (!yyCall(yySelf, yystack, &yy_end, "end")) goto l73;  yyDo(yySelf, yy_4_definition, 0, yystate0); goto l70;
  l73:;	
  YY_RESTORE(yystate70);  if (!yyCall(yySelf, yystack, &yy_begin, "begin")) goto failed;  if (!yyCall(yySelf, yystack, &yy_expression, "expression")) goto failed;  yyDo(yySelf, yy_5_definition, 0, yystate0);
  l70:;	
  YYState yystate74;
  YY_SAVE(yystate74);  if (!yyCall(yySelf, yystack, &yy_SEMICOLON, "SEMICOLON")) goto l74; goto l75;
  l74:;	
  YY_RESTORE(yystate74);
  l75:;	
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_declaration(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "declaration";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yymatchString(yySelf, "%{")) goto failed;  { YY_BEGIN; }
  l76:;	
  YYState yystate77;
  YY_SAVE(yystate77);
  YYState yystate78;
  YY_SAVE(yystate78);  if (!yymatchString(yySelf, "%}")) goto l78; goto l77;
  l78:;	
  YY_RESTORE(yystate78);  if (!yymatchDot(yySelf)) goto l77; goto l76;
  l77:;	
  YY_RESTORE(yystate77);  { YY_END; }  if (!yyCall(yySelf, yystack, &yy_RPERCENT, "RPERCENT")) goto failed;  yyDo(yySelf, yy_1_declaration, 0, yystate0);
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy__(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "_";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;

  l79:;	
  YYState yystate80;
  YY_SAVE(yystate80);
  YYState yystate81;
  YY_SAVE(yystate81);  if (!yyCall(yySelf, yystack, &yy_space, "space")) goto l82; goto l81;
  l82:;	
  YY_RESTORE(yystate81);  if (!yyCall(yySelf, yystack, &yy_comment, "comment")) goto l80;
  l81:;	 goto l79;
  l80:;	
  YY_RESTORE(yystate80);
  goto passed;

  passed:
  return 1;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}

static int yy_grammar(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "grammar";

  YYState yystate0 = yystack->begin;

#define yytext yySelf->text;

  start_rule:;
  if (!yyCall(yySelf, yystack, &yy__, "_")) goto failed;
  YYState yystate85;
  YY_SAVE(yystate85);  if (!yyCall(yySelf, yystack, &yy_declaration, "declaration")) goto l86; goto l85;
  l86:;	
  YY_RESTORE(yystate85);  if (!yyCall(yySelf, yystack, &yy_definition, "definition")) goto failed;
  l85:;	
  l83:;	
  YYState yystate84;
  YY_SAVE(yystate84);
  YYState yystate87;
  YY_SAVE(yystate87);  if (!yyCall(yySelf, yystack, &yy_declaration, "declaration")) goto l88; goto l87;
  l88:;	
  YY_RESTORE(yystate87);  if (!yyCall(yySelf, yystack, &yy_definition, "definition")) goto l84;
  l87:;	 goto l83;
  l84:;	
  YY_RESTORE(yystate84);
  YYState yystate89;
  YY_SAVE(yystate89);  if (!yyCall(yySelf, yystack, &yy_trailer, "trailer")) goto l89; goto l90;
  l89:;	
  YY_RESTORE(yystate89);
  l90:;	  if (!yyCall(yySelf, yystack, &yy_end_of_file, "end_of_file")) goto failed;
  goto passed;

  passed:
  return 1;
  goto failed;

  failed:
  return 0;

#undef yytext
  // for references ONLY
  (void)yyrulename;
}
/*-*- mode: c;-*-*/

#ifndef YY_PART

static int yyParseFrom(YYClass* self, YYRule yystart, const char* name)
{
    int yyok;

    yyStart(self);

    yyClearCache(self);

    self->begin    = self->end = self->pos;
    self->thunkpos = 0;
    self->val      = 0;

    yyok = yyCall(self, (YYStack*) 0, yystart, name);

    if (yyok) yyDone(self);

    yyCommit(self);

    return yyok;

    // for references ONLY
    (void)yyrefill;
    (void)yymatchDot;
    (void)yymatchChar;
    (void)yymatchString;
    (void)yymatchClass;
    (void)yyDo;
    (void)yyText;
    (void)yyDone;
    (void)yyCommit;
    (void)yyAccept;
    (void)yyPush;
    (void)yyPop;
    (void)yySet;
    (void)yyCall;
}

int yyparse(void) {
    //    yyInit(&theParser);
    return yyParseFrom(&theParser, yy_grammar, "grammar");
}

#endif


void yyerror(char *message)
{
  fprintf(stderr, "%s:%d: %s", fileName, lineNumber, message);
  if (theParser.text[0]) fprintf(stderr, " near token '%s'", theParser.text);
  if (theParser.pos < theParser.limit || !feof(input))
    {
      theParser.buf[theParser.limit]= '\0';
      fprintf(stderr, " before text \"");
      while (theParser.pos < theParser.limit)
	{
	  if ('\n' == theParser.buf[theParser.pos] || '\r' == theParser.buf[theParser.pos]) break;
	  fputc(theParser.buf[theParser.pos++], stderr);
	}
      if (theParser.pos == theParser.limit)
	{
	  int c;
	  while (EOF != (c= fgetc(input)) && '\n' != c && '\r' != c)
	    fputc(c, stderr);
	}
      fputc('\"', stderr);
    }
  fprintf(stderr, "\n");
  exit(1);
}

void makeHeader(char *text)
{
  Header *header= (Header *)malloc(sizeof(Header));
  header->text= strdup(text);
  header->next= headers;
  headers= header;
}

void makeTrailer(char *text)
{
  trailer= strdup(text);
}

static void version(char *name)
{
  printf("%s version %d.%d.%d\n", name, COPPER_MAJOR, COPPER_MINOR, COPPER_LEVEL);
}

static void usage(char *name)
{
  version(name);
  fprintf(stderr, "usage: %s [<option>...] [<file>...]\n", name);
  fprintf(stderr, "where <option> can be\n");
  fprintf(stderr, "  -h          print this help information\n");
  fprintf(stderr, "  -o <ofile>  write output to <ofile>\n");
  fprintf(stderr, "  -v          be verbose\n");
  fprintf(stderr, "  -V          print version number and exit\n");
  fprintf(stderr, "if no <file> is given, input is read from stdin\n");
  fprintf(stderr, "if no <ofile> is given, output is written to stdout\n");
  exit(1);
}

int main(int argc, char **argv)
{
  Node *n;
  int   c;

  output= stdout;
  input= stdin;
  lineNumber= 1;
  fileName= "<stdin>";

  while (-1 != (c= getopt(argc, argv, "Vho:v")))
    {
      switch (c)
	{
	case 'V':
	  version(basename(argv[0]));
	  exit(0);

	case 'h':
	  usage(basename(argv[0]));
	  break;

	case 'o':
	  if (!(output= fopen(optarg, "w")))
	    {
	      perror(optarg);
	      exit(1);
	    }
	  break;

	case 'v':
	  verboseFlag= 1;
	  break;

	default:
	  fprintf(stderr, "for usage try: %s -h\n", argv[0]);
	  exit(1);
	}
    }
  argc -= optind;
  argv += optind;

  if (argc)
    {
      for (;  argc;  --argc, ++argv)
	{
	  if (!strcmp(*argv, "-"))
	    {
	      input= stdin;
	      fileName= "<stdin>";
	    }
	  else
	    {
	      if (!(input= fopen(*argv, "r")))
		{
		  perror(*argv);
		  exit(1);
		}
	      fileName= *argv;
	    }
	  lineNumber= 1;
	  if (!yyparse())
	    yyerror("syntax error");
	  if (input != stdin)
	    fclose(input);
	}
    }
  else
    if (!yyparse())
      yyerror("syntax error");

  if (verboseFlag)
    for (n= rules;  n;  n= n->any.next)
      Rule_print(n);

  Rule_compile_c_header();

  for (; headers;  headers= headers->next)
    fprintf(output, "%s\n", headers->text);

  if (rules)
    Rule_compile_c(rules);

  if (trailer)
    fprintf(output, "%s\n", trailer);

  return 0;
}

