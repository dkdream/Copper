/* A recursive-descent parser generated by copper 1.1.0 */


#ifndef COPPER_BOOTSTRAP
#include "copper.inc"
#else
#include "copper.bootstrap.inc"
#endif

#ifndef YY_DECLARED_RULES
#define YY_DECLARED_RULES

#ifndef YY_HEADER
typedef struct _yyclass YYClass;
typedef struct _yystack  YYStack;
#endif

/* rules */
int yy_end_of_line (YYClass* yySelf, YYStack* yystack);
int yy_comment (YYClass* yySelf, YYStack* yystack);
int yy_space (YYClass* yySelf, YYStack* yystack);
int yy_braces (YYClass* yySelf, YYStack* yystack);
int yy_range (YYClass* yySelf, YYStack* yystack);
int yy_char (YYClass* yySelf, YYStack* yystack);
int yy_directive (YYClass* yySelf, YYStack* yystack);
int yy_COLLECT (YYClass* yySelf, YYStack* yystack);
int yy_MARK (YYClass* yySelf, YYStack* yystack);
int yy_END (YYClass* yySelf, YYStack* yystack);
int yy_BEGIN (YYClass* yySelf, YYStack* yystack);
int yy_DOT (YYClass* yySelf, YYStack* yystack);
int yy_class (YYClass* yySelf, YYStack* yystack);
int yy_literal (YYClass* yySelf, YYStack* yystack);
int yy_CLOSE (YYClass* yySelf, YYStack* yystack);
int yy_OPEN (YYClass* yySelf, YYStack* yystack);
int yy_COLON (YYClass* yySelf, YYStack* yystack);
int yy_PLUS (YYClass* yySelf, YYStack* yystack);
int yy_STAR (YYClass* yySelf, YYStack* yystack);
int yy_QUESTION (YYClass* yySelf, YYStack* yystack);
int yy_primary (YYClass* yySelf, YYStack* yystack);
int yy_NOT (YYClass* yySelf, YYStack* yystack);
int yy_suffix (YYClass* yySelf, YYStack* yystack);
int yy_AND (YYClass* yySelf, YYStack* yystack);
int yy_prefix (YYClass* yySelf, YYStack* yystack);
int yy_BAR (YYClass* yySelf, YYStack* yystack);
int yy_sequence (YYClass* yySelf, YYStack* yystack);
int yy_SEMICOLON (YYClass* yySelf, YYStack* yystack);
int yy_begin (YYClass* yySelf, YYStack* yystack);
int yy_end (YYClass* yySelf, YYStack* yystack);
int yy_expression (YYClass* yySelf, YYStack* yystack);
int yy_EQUAL (YYClass* yySelf, YYStack* yystack);
int yy_action (YYClass* yySelf, YYStack* yystack);
int yy_macro (YYClass* yySelf, YYStack* yystack);
int yy_identifier (YYClass* yySelf, YYStack* yystack);
int yy_RPERCENT (YYClass* yySelf, YYStack* yystack);
int yy_end_of_file (YYClass* yySelf, YYStack* yystack);
int yy_trailer (YYClass* yySelf, YYStack* yystack);
int yy_define_rule (YYClass* yySelf, YYStack* yystack);
int yy_define_macro (YYClass* yySelf, YYStack* yystack);
int yy_exportation (YYClass* yySelf, YYStack* yystack);
int yy_declaration (YYClass* yySelf, YYStack* yystack);
int yy_heading (YYClass* yySelf, YYStack* yystack);
int yy__ (YYClass* yySelf, YYStack* yystack);
int yy_grammar (YYClass* yySelf, YYStack* yystack);

#endif

/* actions */
static void yy_12_primary (YYClass* yySelf, YYThunk thunk);
static void yy_11_primary (YYClass* yySelf, YYThunk thunk);
static void yy_10_primary (YYClass* yySelf, YYThunk thunk);
static void yy_9_primary (YYClass* yySelf, YYThunk thunk);
static void yy_8_primary (YYClass* yySelf, YYThunk thunk);
static void yy_7_primary (YYClass* yySelf, YYThunk thunk);
static void yy_6_primary (YYClass* yySelf, YYThunk thunk);
static void yy_5_primary (YYClass* yySelf, YYThunk thunk);
static void yy_4_primary (YYClass* yySelf, YYThunk thunk);
static void yy_3_primary (YYClass* yySelf, YYThunk thunk);
static void yy_2_primary (YYClass* yySelf, YYThunk thunk);
static void yy_1_primary (YYClass* yySelf, YYThunk thunk);
static void yy_3_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_2_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_1_suffix (YYClass* yySelf, YYThunk thunk);
static void yy_4_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_3_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_2_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_1_prefix (YYClass* yySelf, YYThunk thunk);
static void yy_1_sequence (YYClass* yySelf, YYThunk thunk);
static void yy_1_expression (YYClass* yySelf, YYThunk thunk);
static void yy_2_end (YYClass* yySelf, YYThunk thunk);
static void yy_1_end (YYClass* yySelf, YYThunk thunk);
static void yy_2_begin (YYClass* yySelf, YYThunk thunk);
static void yy_1_begin (YYClass* yySelf, YYThunk thunk);
static void yy_5_define_rule (YYClass* yySelf, YYThunk thunk);
static void yy_4_define_rule (YYClass* yySelf, YYThunk thunk);
static void yy_3_define_rule (YYClass* yySelf, YYThunk thunk);
static void yy_2_define_rule (YYClass* yySelf, YYThunk thunk);
static void yy_1_define_rule (YYClass* yySelf, YYThunk thunk);
static void yy_2_define_macro (YYClass* yySelf, YYThunk thunk);
static void yy_1_define_macro (YYClass* yySelf, YYThunk thunk);
static void yy_1_trailer (YYClass* yySelf, YYThunk thunk);
static void yy_1_exportation (YYClass* yySelf, YYThunk thunk);
static void yy_1_declaration (YYClass* yySelf, YYThunk thunk);
static void yy_1_heading (YYClass* yySelf, YYThunk thunk);

static void yy_12_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_12_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction("yySelf->collect_(yySelf, yyrulename);")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_11_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_11_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction("yySelf->mark_(yySelf, yyrulename);")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_10_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_10_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeMark("yySelf->end_(yySelf, yystack)")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_9_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_9_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeMark("yySelf->begin_(yySelf, yystack)")); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_8_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_8_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction(fetchMacro(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_7_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_7_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeAction(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_6_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_6_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeDot()); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_5_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_5_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeClass(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_4_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_4_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeString(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_3_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_3_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeName(findRule(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_primary (%s) '%s'\n", yyrulename, yytext);

   Node *name= makeName(findRule(yytext));  name->name.variable= pop();  push(name); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_primary(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "primary";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_primary (%s) '%s'\n", yyrulename, yytext);

   push(makeVariable(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_3_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_3_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makePlus (pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makeStar (pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_suffix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "suffix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_suffix (%s) '%s'\n", yyrulename, yytext);

   push(makeQuery(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_4_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_4_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePeekNot(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_3_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_3_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePeekFor(pop())); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePredicate(fetchMacro(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_prefix(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "prefix";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_prefix (%s) '%s'\n", yyrulename, yytext);

   push(makePredicate(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_sequence(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "sequence";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_sequence (%s) '%s'\n", yyrulename, yytext);

   Node *f= pop();  push(Sequence_append(pop(), f)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_expression(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "expression";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_expression (%s) '%s'\n", yyrulename, yytext);

   Node *f= pop();  push(Alternate_append(pop(), f)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_end(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "end";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_end (%s) '%s'\n", yyrulename, yytext);

   push(makeMark(fetchMacro(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_end(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "end";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_end (%s) '%s'\n", yyrulename, yytext);

   push(makeMark(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_begin(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "begin";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_begin (%s) '%s'\n", yyrulename, yytext);

   push(makeMark(fetchMacro(yytext))); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_begin(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "begin";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_begin (%s) '%s'\n", yyrulename, yytext);

   push(makeMark(yytext)); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_5_define_rule(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_rule";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_5_define_rule (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_begin); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_4_define_rule(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_rule";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_4_define_rule (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_both); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_3_define_rule(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_rule";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_3_define_rule (%s) '%s'\n", yyrulename, yytext);

   defineRule(simple_rule); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_define_rule(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_rule";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_define_rule (%s) '%s'\n", yyrulename, yytext);

   defineRule(rule_with_end); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_define_rule(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_rule";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_define_rule (%s) '%s'\n", yyrulename, yytext);

   checkRule(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_2_define_macro(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_macro";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_2_define_macro (%s) '%s'\n", yyrulename, yytext);

   defineMacro(yytext);  ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_define_macro(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "define_macro";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_define_macro (%s) '%s'\n", yyrulename, yytext);

   checkMacro(yytext);   ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_trailer(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "trailer";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_trailer (%s) '%s'\n", yyrulename, yytext);

   makeTrailer(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_exportation(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "exportation";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_exportation (%s) '%s'\n", yyrulename, yytext);

   exportRule(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_declaration(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "declaration";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_declaration (%s) '%s'\n", yyrulename, yytext);

   declareRule(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}
static void yy_1_heading(YYClass* yySelf, YYThunk thunk)
{
  static const char* yyrulename = "heading";
  int   yyleng = yyThunkText(yySelf, thunk);
  char* yytext = yySelf->text;
  int   yypos  = yySelf->current.offset;

#define yy yySelf->result
#define yythunkpos yySelf->thunkpos
  yySelf->debug_(yySelf, Debug_action, "do yy_1_heading (%s) '%s'\n", yyrulename, yytext);

   makeHeader(yytext); ;
#undef yy
#undef yythunkpos

  // for references ONLY
  (void)yyrulename;
  (void)yyleng;
  (void)yytext;
  (void)yypos;
}

int yy_end_of_line(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end_of_line";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate2;
  yySelf->save_(yySelf, &yystate2);  if (!yymatchString(yySelf, "\r\n")) goto l3; goto l2;
  l3:;	
  yySelf->restore_(yySelf, &yystate2);  if (!yymatchChar(yySelf, '\n')) goto l4; goto l2;
  l4:;	
  yySelf->restore_(yySelf, &yystate2);  if (!yymatchChar(yySelf, '\r')) goto failed;
  l2:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_comment(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "comment";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '#')) goto failed;
  l5:;	
  YYState yystate6;
  yySelf->save_(yySelf, &yystate6);
  YYState yystate7;
  yySelf->save_(yySelf, &yystate7);  if (!yySelf->apply_(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto l7; goto l6;
  l7:;	
  yySelf->restore_(yySelf, &yystate7);  if (!yymatchDot(yySelf)) goto l6; goto l5;
  l6:;	
  yySelf->restore_(yySelf, &yystate6);  if (!yySelf->apply_(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_space(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "space";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate8;
  yySelf->save_(yySelf, &yystate8);  if (!yymatchChar(yySelf, ' ')) goto l9; goto l8;
  l9:;	
  yySelf->restore_(yySelf, &yystate8);  if (!yymatchChar(yySelf, '\t')) goto l10; goto l8;
  l10:;	
  yySelf->restore_(yySelf, &yystate8);  if (!yySelf->apply_(yySelf, yystack, &yy_end_of_line, "end_of_line")) goto failed;
  l8:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_braces(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "braces";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate11;
  yySelf->save_(yySelf, &yystate11);  if (!yymatchChar(yySelf, '{')) goto l12;
  l13:;	
  YYState yystate14;
  yySelf->save_(yySelf, &yystate14);
  YYState yystate15;
  yySelf->save_(yySelf, &yystate15);  if (!yymatchChar(yySelf, '}')) goto l15; goto l14;
  l15:;	
  yySelf->restore_(yySelf, &yystate15);  if (!yymatchDot(yySelf)) goto l14; goto l13;
  l14:;	
  yySelf->restore_(yySelf, &yystate14);  if (!yymatchChar(yySelf, '}')) goto l12; goto l11;
  l12:;	
  yySelf->restore_(yySelf, &yystate11);
  YYState yystate16;
  yySelf->save_(yySelf, &yystate16);  if (!yymatchChar(yySelf, '}')) goto l16; goto failed;
  l16:;	
  yySelf->restore_(yySelf, &yystate16);  if (!yymatchDot(yySelf)) goto failed;
  l11:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_range(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "range";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate17;
  yySelf->save_(yySelf, &yystate17);  if (!yySelf->apply_(yySelf, yystack, &yy_char, "char")) goto l18;  if (!yymatchChar(yySelf, '-')) goto l18;  if (!yySelf->apply_(yySelf, yystack, &yy_char, "char")) goto l18; goto l17;
  l18:;	
  yySelf->restore_(yySelf, &yystate17);  if (!yySelf->apply_(yySelf, yystack, &yy_char, "char")) goto failed;
  l17:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_char(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "char";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate19;
  yySelf->save_(yySelf, &yystate19);  if (!yymatchChar(yySelf, '\\')) goto l20;  if (!yymatchClass(yySelf, "abefnrtv\'\"\\[\\]\\\\", (unsigned char *)"\000\000\000\000\204\000\000\000\000\000\000\070\146\100\124\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l20; goto l19;
  l20:;	
  yySelf->restore_(yySelf, &yystate19);  if (!yymatchChar(yySelf, '\\')) goto l21;  if (!yymatchClass(yySelf, "0-3", (unsigned char *)"\000\000\000\000\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l21; goto l19;
  l21:;	
  yySelf->restore_(yySelf, &yystate19);  if (!yymatchChar(yySelf, '\\')) goto l22;  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l22;
  YYState yystate23;
  yySelf->save_(yySelf, &yystate23);  if (!yymatchClass(yySelf, "0-7", (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l23; goto l24;
  l23:;	
  yySelf->restore_(yySelf, &yystate23);
  l24:;	 goto l19;
  l22:;	
  yySelf->restore_(yySelf, &yystate19);
  YYState yystate25;
  yySelf->save_(yySelf, &yystate25);  if (!yymatchChar(yySelf, '\\')) goto l25; goto failed;
  l25:;	
  yySelf->restore_(yySelf, &yystate25);  if (!yymatchDot(yySelf)) goto failed;
  l19:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_directive(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "directive";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate26;
  yySelf->save_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%{")) goto l27; goto l26;
  l27:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%define")) goto l28; goto l26;
  l28:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%declare")) goto l29; goto l26;
  l29:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%export")) goto l30; goto l26;
  l30:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%%")) goto l31; goto l26;
  l31:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%begin")) goto l32; goto l26;
  l32:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%end")) goto l33; goto l26;
  l33:;	
  yySelf->restore_(yySelf, &yystate26);  if (!yymatchString(yySelf, "%}")) goto failed;
  l26:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_COLLECT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "COLLECT";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '$')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_MARK(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "MARK";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '@')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_END(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "END";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '>')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_BEGIN(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "BEGIN";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '<')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_DOT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "DOT";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '.')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_class(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "class";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '[')) goto failed;  { yySelf->begin_(yySelf, yystack); }
  l34:;	
  YYState yystate35;
  yySelf->save_(yySelf, &yystate35);
  YYState yystate36;
  yySelf->save_(yySelf, &yystate36);  if (!yymatchChar(yySelf, ']')) goto l36; goto l35;
  l36:;	
  yySelf->restore_(yySelf, &yystate36);  if (!yySelf->apply_(yySelf, yystack, &yy_range, "range")) goto l35; goto l34;
  l35:;	
  yySelf->restore_(yySelf, &yystate35);  { yySelf->end_(yySelf, yystack); }  if (!yymatchChar(yySelf, ']')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_literal(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "literal";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate37;
  yySelf->save_(yySelf, &yystate37);  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l38;  { yySelf->begin_(yySelf, yystack); }
  l39:;	
  YYState yystate40;
  yySelf->save_(yySelf, &yystate40);
  YYState yystate41;
  yySelf->save_(yySelf, &yystate41);  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l41; goto l40;
  l41:;	
  yySelf->restore_(yySelf, &yystate41);  if (!yySelf->apply_(yySelf, yystack, &yy_char, "char")) goto l40; goto l39;
  l40:;	
  yySelf->restore_(yySelf, &yystate40);  { yySelf->end_(yySelf, yystack); }  if (!yymatchClass(yySelf, "\'", (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l38;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto l38; goto l37;
  l38:;	
  yySelf->restore_(yySelf, &yystate37);  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;  { yySelf->begin_(yySelf, yystack); }
  l42:;	
  YYState yystate43;
  yySelf->save_(yySelf, &yystate43);
  YYState yystate44;
  yySelf->save_(yySelf, &yystate44);  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l44; goto l43;
  l44:;	
  yySelf->restore_(yySelf, &yystate44);  if (!yySelf->apply_(yySelf, yystack, &yy_char, "char")) goto l43; goto l42;
  l43:;	
  yySelf->restore_(yySelf, &yystate43);  { yySelf->end_(yySelf, yystack); }  if (!yymatchClass(yySelf, "\"", (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  l37:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_CLOSE(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "CLOSE";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, ')')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_OPEN(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "OPEN";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '(')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_COLON(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "COLON";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, ':')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_PLUS(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "PLUS";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '+')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_STAR(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "STAR";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '*')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_QUESTION(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "QUESTION";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '?')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_primary(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "primary";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate45;
  yySelf->save_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto l46;  yyDo(yySelf, " yy_1_primary", yy_1_primary, 0, yystate0);  if (!yySelf->apply_(yySelf, yystack, &yy_COLON, "COLON")) goto l46;  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto l46;
  YYState yystate47;
  yySelf->save_(yySelf, &yystate47);  if (!yySelf->apply_(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto l47; goto l46;
  l47:;	
  yySelf->restore_(yySelf, &yystate47);  yyDo(yySelf, " yy_2_primary", yy_2_primary, 0, yystate0); goto l45;
  l46:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto l48;
  YYState yystate49;
  yySelf->save_(yySelf, &yystate49);  if (!yySelf->apply_(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto l49; goto l48;
  l49:;	
  yySelf->restore_(yySelf, &yystate49);  yyDo(yySelf, " yy_3_primary", yy_3_primary, 0, yystate0); goto l45;
  l48:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_OPEN, "OPEN")) goto l50;  if (!yySelf->apply_(yySelf, yystack, &yy_expression, "expression")) goto l50;  if (!yySelf->apply_(yySelf, yystack, &yy_CLOSE, "CLOSE")) goto l50; goto l45;
  l50:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_literal, "literal")) goto l51;  yyDo(yySelf, " yy_4_primary", yy_4_primary, 0, yystate0); goto l45;
  l51:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_class, "class")) goto l52;  yyDo(yySelf, " yy_5_primary", yy_5_primary, 0, yystate0); goto l45;
  l52:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_DOT, "DOT")) goto l53;  yyDo(yySelf, " yy_6_primary", yy_6_primary, 0, yystate0); goto l45;
  l53:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_action, "action")) goto l54;  yyDo(yySelf, " yy_7_primary", yy_7_primary, 0, yystate0); goto l45;
  l54:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_macro, "macro")) goto l55;  yyDo(yySelf, " yy_8_primary", yy_8_primary, 0, yystate0); goto l45;
  l55:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_BEGIN, "BEGIN")) goto l56;  yyDo(yySelf, " yy_9_primary", yy_9_primary, 0, yystate0); goto l45;
  l56:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_END, "END")) goto l57;  yyDo(yySelf, " yy_10_primary", yy_10_primary, 0, yystate0); goto l45;
  l57:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_MARK, "MARK")) goto l58;  yyDo(yySelf, " yy_11_primary", yy_11_primary, 0, yystate0); goto l45;
  l58:;	
  yySelf->restore_(yySelf, &yystate45);  if (!yySelf->apply_(yySelf, yystack, &yy_COLLECT, "COLLECT")) goto failed;  yyDo(yySelf, " yy_12_primary", yy_12_primary, 0, yystate0);
  l45:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_NOT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "NOT";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '!')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_suffix(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "suffix";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yySelf->apply_(yySelf, yystack, &yy_primary, "primary")) goto failed;
  YYState yystate59;
  yySelf->save_(yySelf, &yystate59);
  YYState yystate61;
  yySelf->save_(yySelf, &yystate61);  if (!yySelf->apply_(yySelf, yystack, &yy_QUESTION, "QUESTION")) goto l62;  yyDo(yySelf, " yy_1_suffix", yy_1_suffix, 0, yystate0); goto l61;
  l62:;	
  yySelf->restore_(yySelf, &yystate61);  if (!yySelf->apply_(yySelf, yystack, &yy_STAR, "STAR")) goto l63;  yyDo(yySelf, " yy_2_suffix", yy_2_suffix, 0, yystate0); goto l61;
  l63:;	
  yySelf->restore_(yySelf, &yystate61);  if (!yySelf->apply_(yySelf, yystack, &yy_PLUS, "PLUS")) goto l59;  yyDo(yySelf, " yy_3_suffix", yy_3_suffix, 0, yystate0);
  l61:;	 goto l60;
  l59:;	
  yySelf->restore_(yySelf, &yystate59);
  l60:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_AND(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "AND";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '&')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_prefix(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "prefix";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate64;
  yySelf->save_(yySelf, &yystate64);  if (!yySelf->apply_(yySelf, yystack, &yy_AND, "AND")) goto l65;  if (!yySelf->apply_(yySelf, yystack, &yy_action, "action")) goto l65;  yyDo(yySelf, " yy_1_prefix", yy_1_prefix, 0, yystate0); goto l64;
  l65:;	
  yySelf->restore_(yySelf, &yystate64);  if (!yySelf->apply_(yySelf, yystack, &yy_AND, "AND")) goto l66;  if (!yySelf->apply_(yySelf, yystack, &yy_macro, "macro")) goto l66;  yyDo(yySelf, " yy_2_prefix", yy_2_prefix, 0, yystate0); goto l64;
  l66:;	
  yySelf->restore_(yySelf, &yystate64);  if (!yySelf->apply_(yySelf, yystack, &yy_AND, "AND")) goto l67;  if (!yySelf->apply_(yySelf, yystack, &yy_suffix, "suffix")) goto l67;  yyDo(yySelf, " yy_3_prefix", yy_3_prefix, 0, yystate0); goto l64;
  l67:;	
  yySelf->restore_(yySelf, &yystate64);  if (!yySelf->apply_(yySelf, yystack, &yy_NOT, "NOT")) goto l68;  if (!yySelf->apply_(yySelf, yystack, &yy_suffix, "suffix")) goto l68;  yyDo(yySelf, " yy_4_prefix", yy_4_prefix, 0, yystate0); goto l64;
  l68:;	
  yySelf->restore_(yySelf, &yystate64);  if (!yySelf->apply_(yySelf, yystack, &yy_suffix, "suffix")) goto failed;
  l64:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_BAR(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "BAR";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '|')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_sequence(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "sequence";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yySelf->apply_(yySelf, yystack, &yy_prefix, "prefix")) goto failed;
  l69:;	
  YYState yystate70;
  yySelf->save_(yySelf, &yystate70);  if (!yySelf->apply_(yySelf, yystack, &yy_prefix, "prefix")) goto l70;  yyDo(yySelf, " yy_1_sequence", yy_1_sequence, 0, yystate0); goto l69;
  l70:;	
  yySelf->restore_(yySelf, &yystate70);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_SEMICOLON(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "SEMICOLON";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, ';')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_begin(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "begin";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%begin")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  YYState yystate71;
  yySelf->save_(yySelf, &yystate71);  if (!yySelf->apply_(yySelf, yystack, &yy_action, "action")) goto l72;  yyDo(yySelf, " yy_1_begin", yy_1_begin, 0, yystate0); goto l71;
  l72:;	
  yySelf->restore_(yySelf, &yystate71);  if (!yySelf->apply_(yySelf, yystack, &yy_macro, "macro")) goto failed;  yyDo(yySelf, " yy_2_begin", yy_2_begin, 0, yystate0);
  l71:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_end(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%end")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  YYState yystate73;
  yySelf->save_(yySelf, &yystate73);  if (!yySelf->apply_(yySelf, yystack, &yy_action, "action")) goto l74;  yyDo(yySelf, " yy_1_end", yy_1_end, 0, yystate0); goto l73;
  l74:;	
  yySelf->restore_(yySelf, &yystate73);  if (!yySelf->apply_(yySelf, yystack, &yy_macro, "macro")) goto failed;  yyDo(yySelf, " yy_2_end", yy_2_end, 0, yystate0);
  l73:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_expression(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "expression";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yySelf->apply_(yySelf, yystack, &yy_sequence, "sequence")) goto failed;
  l75:;	
  YYState yystate76;
  yySelf->save_(yySelf, &yystate76);  if (!yySelf->apply_(yySelf, yystack, &yy_BAR, "BAR")) goto l76;  if (!yySelf->apply_(yySelf, yystack, &yy_sequence, "sequence")) goto l76;  yyDo(yySelf, " yy_1_expression", yy_1_expression, 0, yystate0); goto l75;
  l76:;	
  yySelf->restore_(yySelf, &yystate76);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_EQUAL(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "EQUAL";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '=')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_action(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "action";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchChar(yySelf, '{')) goto failed;  { yySelf->begin_(yySelf, yystack); }
  l77:;	
  YYState yystate78;
  yySelf->save_(yySelf, &yystate78);  if (!yySelf->apply_(yySelf, yystack, &yy_braces, "braces")) goto l78; goto l77;
  l78:;	
  yySelf->restore_(yySelf, &yystate78);  { yySelf->end_(yySelf, yystack); }  if (!yymatchChar(yySelf, '}')) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_macro(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "macro";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate79;
  yySelf->save_(yySelf, &yystate79);  if (!yySelf->apply_(yySelf, yystack, &yy_directive, "directive")) goto l79; goto failed;
  l79:;	
  yySelf->restore_(yySelf, &yystate79);  if (!yymatchChar(yySelf, '%')) goto failed;  { yySelf->begin_(yySelf, yystack); }  if (!yymatchClass(yySelf, "-a-zA-Z_", (unsigned char *)"\000\000\000\000\000\040\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;
  l80:;	
  YYState yystate81;
  yySelf->save_(yySelf, &yystate81);  if (!yymatchClass(yySelf, "-a-zA-Z_0-9", (unsigned char *)"\000\000\000\000\000\040\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l81; goto l80;
  l81:;	
  yySelf->restore_(yySelf, &yystate81);  { yySelf->end_(yySelf, yystack); }  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_identifier(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "identifier";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  { yySelf->begin_(yySelf, yystack); }  if (!yymatchClass(yySelf, "-a-zA-Z_", (unsigned char *)"\000\000\000\000\000\040\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto failed;
  l82:;	
  YYState yystate83;
  yySelf->save_(yySelf, &yystate83);  if (!yymatchClass(yySelf, "-a-zA-Z_0-9", (unsigned char *)"\000\000\000\000\000\040\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l83; goto l82;
  l83:;	
  yySelf->restore_(yySelf, &yystate83);  { yySelf->end_(yySelf, yystack); }  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_RPERCENT(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "RPERCENT";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%}")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_end_of_file(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "end_of_file";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  YYState yystate84;
  yySelf->save_(yySelf, &yystate84);  if (!yymatchDot(yySelf)) goto l84; goto failed;
  l84:;	
  yySelf->restore_(yySelf, &yystate84);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_trailer(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "trailer";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%%")) goto failed;  { yySelf->begin_(yySelf, yystack); }
  l85:;	
  YYState yystate86;
  yySelf->save_(yySelf, &yystate86);  if (!yymatchDot(yySelf)) goto l86; goto l85;
  l86:;	
  yySelf->restore_(yySelf, &yystate86);  { yySelf->end_(yySelf, yystack); }  yyDo(yySelf, " yy_1_trailer", yy_1_trailer, 0, yystate0);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_define_rule(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "define_rule";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto failed;  yyDo(yySelf, " yy_1_define_rule", yy_1_define_rule, 0, yystate0);  if (!yySelf->apply_(yySelf, yystack, &yy_EQUAL, "EQUAL")) goto failed;
  YYState yystate87;
  yySelf->save_(yySelf, &yystate87);  if (!yySelf->apply_(yySelf, yystack, &yy_expression, "expression")) goto l88;  if (!yySelf->apply_(yySelf, yystack, &yy_end, "end")) goto l88;  yyDo(yySelf, " yy_2_define_rule", yy_2_define_rule, 0, yystate0); goto l87;
  l88:;	
  yySelf->restore_(yySelf, &yystate87);  if (!yySelf->apply_(yySelf, yystack, &yy_expression, "expression")) goto l89;  yyDo(yySelf, " yy_3_define_rule", yy_3_define_rule, 0, yystate0); goto l87;
  l89:;	
  yySelf->restore_(yySelf, &yystate87);  if (!yySelf->apply_(yySelf, yystack, &yy_begin, "begin")) goto l90;  if (!yySelf->apply_(yySelf, yystack, &yy_expression, "expression")) goto l90;  if (!yySelf->apply_(yySelf, yystack, &yy_end, "end")) goto l90;  yyDo(yySelf, " yy_4_define_rule", yy_4_define_rule, 0, yystate0); goto l87;
  l90:;	
  yySelf->restore_(yySelf, &yystate87);  if (!yySelf->apply_(yySelf, yystack, &yy_begin, "begin")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy_expression, "expression")) goto failed;  yyDo(yySelf, " yy_5_define_rule", yy_5_define_rule, 0, yystate0);
  l87:;	
  YYState yystate91;
  yySelf->save_(yySelf, &yystate91);  if (!yySelf->apply_(yySelf, yystack, &yy_SEMICOLON, "SEMICOLON")) goto l91; goto l92;
  l91:;	
  yySelf->restore_(yySelf, &yystate91);
  l92:;	
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_define_macro(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "define_macro";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%define")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy_macro, "macro")) goto failed;  yyDo(yySelf, " yy_1_define_macro", yy_1_define_macro, 0, yystate0);  if (!yySelf->apply_(yySelf, yystack, &yy_action, "action")) goto failed;  yyDo(yySelf, " yy_2_define_macro", yy_2_define_macro, 0, yystate0);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_exportation(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "exportation";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%export")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto failed;  yyDo(yySelf, " yy_1_exportation", yy_1_exportation, 0, yystate0);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_declaration(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "declaration";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%declare")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;  if (!yySelf->apply_(yySelf, yystack, &yy_identifier, "identifier")) goto failed;  yyDo(yySelf, " yy_1_declaration", yy_1_declaration, 0, yystate0);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_heading(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "heading";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yymatchString(yySelf, "%{")) goto failed;  { yySelf->begin_(yySelf, yystack); }
  l93:;	
  YYState yystate94;
  yySelf->save_(yySelf, &yystate94);
  YYState yystate95;
  yySelf->save_(yySelf, &yystate95);  if (!yymatchString(yySelf, "%}")) goto l95; goto l94;
  l95:;	
  yySelf->restore_(yySelf, &yystate95);  if (!yymatchDot(yySelf)) goto l94; goto l93;
  l94:;	
  yySelf->restore_(yySelf, &yystate94);  { yySelf->end_(yySelf, yystack); }  if (!yySelf->apply_(yySelf, yystack, &yy_RPERCENT, "RPERCENT")) goto failed;  yyDo(yySelf, " yy_1_heading", yy_1_heading, 0, yystate0);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy__(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "_";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;

  l96:;	
  YYState yystate97;
  yySelf->save_(yySelf, &yystate97);
  YYState yystate98;
  yySelf->save_(yySelf, &yystate98);  if (!yySelf->apply_(yySelf, yystack, &yy_space, "space")) goto l99; goto l98;
  l99:;	
  yySelf->restore_(yySelf, &yystate98);  if (!yySelf->apply_(yySelf, yystack, &yy_comment, "comment")) goto l97;
  l98:;	 goto l96;
  l97:;	
  yySelf->restore_(yySelf, &yystate97);
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}

int yy_grammar(YYClass* yySelf, YYStack* yystack)
{
  static const char* yyrulename = "grammar";

  YYState yystate0 = yystack->begin;

  yySelf->debug_(yySelf, Debug_rule_match, "enter %s \n", yyrulename);

  start_rule:;
  if (!yySelf->apply_(yySelf, yystack, &yy__, "_")) goto failed;
  YYState yystate102;
  yySelf->save_(yySelf, &yystate102);  if (!yySelf->apply_(yySelf, yystack, &yy_heading, "heading")) goto l103; goto l102;
  l103:;	
  yySelf->restore_(yySelf, &yystate102);  if (!yySelf->apply_(yySelf, yystack, &yy_declaration, "declaration")) goto l104; goto l102;
  l104:;	
  yySelf->restore_(yySelf, &yystate102);  if (!yySelf->apply_(yySelf, yystack, &yy_exportation, "exportation")) goto l105; goto l102;
  l105:;	
  yySelf->restore_(yySelf, &yystate102);  if (!yySelf->apply_(yySelf, yystack, &yy_define_macro, "define_macro")) goto l106; goto l102;
  l106:;	
  yySelf->restore_(yySelf, &yystate102);  if (!yySelf->apply_(yySelf, yystack, &yy_define_rule, "define_rule")) goto failed;
  l102:;	
  l100:;	
  YYState yystate101;
  yySelf->save_(yySelf, &yystate101);
  YYState yystate107;
  yySelf->save_(yySelf, &yystate107);  if (!yySelf->apply_(yySelf, yystack, &yy_heading, "heading")) goto l108; goto l107;
  l108:;	
  yySelf->restore_(yySelf, &yystate107);  if (!yySelf->apply_(yySelf, yystack, &yy_declaration, "declaration")) goto l109; goto l107;
  l109:;	
  yySelf->restore_(yySelf, &yystate107);  if (!yySelf->apply_(yySelf, yystack, &yy_exportation, "exportation")) goto l110; goto l107;
  l110:;	
  yySelf->restore_(yySelf, &yystate107);  if (!yySelf->apply_(yySelf, yystack, &yy_define_macro, "define_macro")) goto l111; goto l107;
  l111:;	
  yySelf->restore_(yySelf, &yystate107);  if (!yySelf->apply_(yySelf, yystack, &yy_define_rule, "define_rule")) goto l101;
  l107:;	 goto l100;
  l101:;	
  yySelf->restore_(yySelf, &yystate101);
  YYState yystate112;
  yySelf->save_(yySelf, &yystate112);  if (!yySelf->apply_(yySelf, yystack, &yy_trailer, "trailer")) goto l112; goto l113;
  l112:;	
  yySelf->restore_(yySelf, &yystate112);
  l113:;	  if (!yySelf->apply_(yySelf, yystack, &yy_end_of_file, "end_of_file")) goto failed;
  goto passed;

  passed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (1)\n", yyrulename);
  return 1;
  goto failed;

  failed:
  yySelf->debug_(yySelf, Debug_rule_match, "exiting %s (0)\n", yyrulename);
  return 0;
  // for references ONLY
  (void)yyrulename;
  (void)yystate0;
  if (0) goto start_rule;
}
