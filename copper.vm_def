$cip  := current input pointer
$cs   := current symbol (the character the cip points to)


success                       = return true to caller
falure                        = return false to caller
nothing                       = do nothing
next                          = add 1 to the current input pointer
mark  $x                      = store the current input pointer  in $x
reset $x                      = change the current input pointer to $x
repeat (body)                 = repeat body until sucess or falure
match expr (onFalse ; onTrue) = match expr then if success do onTrue otherwize do onFalse
is chr   (onFalse ; onTrue)   = if chr == $cs then do onTrue otherwize do onFalse
in range (onFalse ; onTrue)   = if $cs is in range then do onTrue otherwize do onFalse


e1 e2 ;    == mark $x, match e1 (reset $x, falure ; match e2 ( reset $x, falure ; success ))
e1 e2 /    == mark $x, match e1 (reset $x, match e2 ( reset $x, falure ; success ); success)
e *        == repeat (mark $x; match e ( reset $x, success ; nothing )) 
e +        == mark $x, match e (falure ; repeat (mark $x; match e ( reset $x, success ; nothing )))
e ?        == mark $x, match e ( reset $x, success ; success )
e &        == mark $x, match e ( reset $x, falure ; reset $x, success )
e !        == mark $x, match e ( reset $x, success ; reset $x, falure )
chr        == is chr ( falure ; next, success ) 
chr1..chr2 == in chr1..chr2 ( falure ; next, success )
@name      == mark $x, match recall name  ( reset $x, falue ; reset $x, success )

 
     
    